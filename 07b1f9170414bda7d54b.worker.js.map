{"version":3,"sources":["../webpack/bootstrap","../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","sudoku/SudokuEventType.tsx","sudoku/SudokuPosition.tsx","sudoku/SudokuBox.tsx","sudoku/CantBeFoundEvent.tsx","finder/numberFound2cantBe/BoxCantBeRule.tsx","finder/numberFound2cantBe/HorizontalCantBeRule.tsx","finder/numberFound2cantBe/VerticalCantBeRule.tsx","finder/numberFound2cantBe/OnePositionCantBeRule.tsx","sudoku/NumberFoundEvent.tsx","finder/cantBe2NumberFound/OnlyOnePlaceHorizontalLine.tsx","finder/cantBe2NumberFound/OnlyOnePlaceVerticalLine.tsx","finder/cantBe2NumberFound/OnlyOnePlaceBox.tsx","finder/cantBe2NumberFound/OnePositionFinder.tsx","sudoku/EventFilter.tsx","sudoku/RuleOrchestration.tsx","sudoku.worker.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","length","descriptor","configurable","writable","_createClass","protoProps","staticProps","SudokuEventType","SudokuPosition","xCoordinate","yCoordinate","this","SudokuBox","x","y","Error","allInstances","result","sudokuCoordinateFor","forEach","yC","xC","position","push","allBoxCoordinates","all","postion","getXCoordinate","getYCoordinate","boxXCoordinate","boxCoordinateFor","boxYCoordinate","coordinate","createAll","CantBeFoundEvent","number","from","type","CANT_BE","BoxCantBeRule","ruleName","numberFoundEvent","box","createByPosition","getPosition","allSudokuPositionInThisBox","getNumber","HorizontalCantBeRule","xk","yk","VerticalCantBeRule","OnePositionCantBeRule","NumberFoundEvent","NUMBER_FOUND","OnlyOnePlaceHorizontalLine","memory","initMemory","cantBes","cantBe","canBeForNumberInLine","find","it","onlyPossiblePosition","Map","numbers","map1","set","yCoordinates","OnlyOnePlaceVerticalLine","speicher","initSpeicher","xCoordinates","samePosition","one","two","OnlyOnePlaceBox","init","results","info","nTNumber","notHeres","newPos","OnePositionFinder","notThisNumber","createBoolean3dArray","event","anzFalse","lastFalsePosition","array3d","j","k","EventFilter","numberFound","toFilter","filtered","numberFound2cantBeRules","cantBe2NumberFound","eventFilter","ruleOrchestration","postMessage","foundNumbers","cantBeRulesResults","rule","foundNumber","concat","finderLogic","removeAlreadySeen","addEventListener","data","console","log","sudokuEvent","field","handleGivenNumber"],"mappings":"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","file":"07b1f9170414bda7d54b.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","enum SudokuEventType {\n  CANT_BE,\n  NUMBER_FOUND\n}\nexport default SudokuEventType;\n","import SudokuXCoordinate from \"./SudokuXCoordinate\";\nimport SudokuYCoordinate from \"./SudokuYCoordinate\";\n\nexport default class SudokuPosition {\n  readonly xCoordinate: SudokuXCoordinate;\n  readonly yCoordinate: SudokuYCoordinate;\n\n  constructor(xCoordinate: SudokuXCoordinate, yCoordinate: SudokuYCoordinate) {\n    this.xCoordinate = xCoordinate;\n    this.yCoordinate = yCoordinate;\n  }\n\n  getXCoordinate() {\n    return this.xCoordinate;\n  }\n\n  getYCoordinate() {\n    return this.yCoordinate;\n  }\n\n  toString() {\n    return \"Pos: [\" + this.xCoordinate + \",\" + this.yCoordinate + \"]\";\n  }\n\n  valueOf() {\n    return \"[\" + this.xCoordinate + \"][\" + this.yCoordinate + \"]\";\n  }\n}\n","import SudokuPosition from \"./SudokuPosition\";\nimport SudokuYCoordinate from \"./SudokuYCoordinate\";\nimport SudokuXCoordinate from \"./SudokuXCoordinate\";\n\ntype BoxCoordinate = 0 | 1 | 2;\n\nexport default class SudokuBox {\n  private readonly x: BoxCoordinate;\n  private readonly y: BoxCoordinate;\n\n  private static allInstances: SudokuBox[][] = SudokuBox.createAll();\n\n  private constructor(x: BoxCoordinate, y: BoxCoordinate) {\n    if (x < 0 || y < 0 || x > 2 || y > 2) {\n      throw new Error(\"illegal argument x:\" + x + \" y: \" + y);\n    }\n    this.x = x;\n    this.y = y;\n  }\n\n  getX() {\n    return this.x;\n  }\n\n  getY() {\n    return this.y;\n  }\n\n  getAll() {\n    return SudokuBox.allInstances;\n  }\n\n  private static createAll() {\n    const allBoxCoordinates: BoxCoordinate[] = [0, 1, 2];\n    const all: SudokuBox[][] = [[], [], []];\n    allBoxCoordinates.forEach(x => {\n      allBoxCoordinates.forEach(y => {\n        all[x][y] = new SudokuBox(x, y);\n      });\n    });\n    return all;\n  }\n\n  static createByPosition(postion: SudokuPosition) {\n    const x = postion.getXCoordinate();\n    const y = postion.getYCoordinate();\n    const boxXCoordinate = this.boxCoordinateFor(x);\n    const boxYCoordinate = this.boxCoordinateFor(y);\n    return this.allInstances[boxXCoordinate][boxYCoordinate];\n  }\n\n  private static boxCoordinateFor(\n    coordinate: SudokuXCoordinate | SudokuYCoordinate\n  ) {\n    if (coordinate === 0 || coordinate === 1 || coordinate === 2) {\n      return 0;\n    } else if (coordinate === 3 || coordinate === 4 || coordinate === 5) {\n      return 1;\n    } else {\n      return 2;\n    }\n  }\n\n  private static sudokuCoordinateFor(\n    coordinate: BoxCoordinate\n  ): Array<SudokuXCoordinate | SudokuYCoordinate> {\n    if (coordinate === 0) {\n      return [0, 1, 2];\n    } else if (coordinate === 1) {\n      return [3, 4, 5];\n    } else {\n      return [6, 7, 8];\n    }\n  }\n\n  static create(x: number, y: number) {\n    return this.allInstances[x][y];\n  }\n\n  allSudokuPositionInThisBox() {\n    let result: SudokuPosition[] = [];\n    SudokuBox.sudokuCoordinateFor(this.y).forEach(yC => {\n      SudokuBox.sudokuCoordinateFor(this.x).forEach(xC => {\n        const position = new SudokuPosition(xC, yC);\n        result.push(position);\n      });\n    });\n    return result;\n  }\n\n  toString() {\n    return \"Box: [\" + this.x + \",\" + this.y + \"]\";\n  }\n}\n","import SudokuPosition from \"./SudokuPosition\";\nimport SudokuEventType from \"./SudokuEventType\";\nimport SudokuNumber from \"./SudokuNumber\";\n\nexport default class CantBeFoundEvent {\n  readonly type: SudokuEventType = SudokuEventType.CANT_BE;\n  readonly position: SudokuPosition;\n  readonly number: SudokuNumber;\n  readonly from: string;\n\n  constructor(postion: SudokuPosition, number: SudokuNumber, from: string) {\n    this.position = postion;\n    this.number = number;\n    this.from = from;\n  }\n\n  getNumber() {\n    return this.number;\n  }\n\n  getPosition() {\n    return this.position;\n  }\n\n  getFrom() {\n    return this.from;\n  }\n}\n","import SudokuBox from \"../../sudoku/SudokuBox\";\nimport CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport NumberFound2CantBe from \"./NumberFound2CantBe\";\n\nexport default class BoxCantBeRule implements NumberFound2CantBe {\n  private ruleName = \"BoxCantBeRule\";\n\n  finderLogic(numberFoundEvent: NumberFoundEvent) {\n    const result = [];\n    const box = SudokuBox.createByPosition(numberFoundEvent.getPosition());\n\n    for (let position of box.allSudokuPositionInThisBox()) {\n      if (\n        position.getYCoordinate() !==\n          numberFoundEvent.getPosition().getYCoordinate() ||\n        position.getXCoordinate() !==\n          numberFoundEvent.getPosition().getXCoordinate()\n      ) {\n        result.push(\n          new CantBeFoundEvent(\n            position,\n            numberFoundEvent.getNumber(),\n            this.ruleName\n          )\n        );\n      }\n    }\n\n    return result;\n  }\n}\n","import CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport NumberFound2CantBe from \"./NumberFound2CantBe\";\nimport SudokuYCoordinate from \"../../sudoku/SudokuYCoordinate\";\n\nexport default class HorizontalCantBeRule implements NumberFound2CantBe {\n  name = \"HorizontalCantBeRule\";\n\n  finderLogic(numberFoundEvent: NumberFoundEvent) {\n    const result: CantBeFoundEvent[] = [];\n    const yCoordinates: SudokuYCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n\n    let xk = numberFoundEvent.getPosition().getXCoordinate();\n    yCoordinates.forEach(yk => {\n      if (yk !== numberFoundEvent.getPosition().getYCoordinate()) {\n        result.push(\n          new CantBeFoundEvent(\n            new SudokuPosition(xk, yk),\n            numberFoundEvent.getNumber(),\n            this.name\n          )\n        );\n      }\n    });\n\n    return result;\n  }\n}\n","import CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport NumberFound2CantBe from \"./NumberFound2CantBe\";\nimport SudokuXCoordinate from \"../../sudoku/SudokuXCoordinate\";\n\nexport default class VerticalCantBeRule implements NumberFound2CantBe {\n  name = \"VerticalCantBeRule\";\n\n  finderLogic(numberFoundEvent: NumberFoundEvent) {\n    const result: CantBeFoundEvent[] = [];\n    const xCoordinates: SudokuXCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n\n    let yk = numberFoundEvent.getPosition().getYCoordinate();\n    xCoordinates.forEach(xk => {\n      if (xk !== numberFoundEvent.getPosition().getXCoordinate()) {\n        result.push(\n          new CantBeFoundEvent(\n            new SudokuPosition(xk, yk),\n            numberFoundEvent.getNumber(),\n            this.name\n          )\n        );\n      }\n    });\n    return result;\n  }\n}\n","import CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport NumberFound2CantBe from \"./NumberFound2CantBe\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\n\nexport default class OnePositionCantBeRule implements NumberFound2CantBe {\n  name = \"OnePositionCantBeRule\";\n\n  finderLogic(numberFoundEvent: NumberFoundEvent) {\n    const result: CantBeFoundEvent[] = [];\n    const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    numbers.forEach(i => {\n      if (i !== numberFoundEvent.getNumber()) {\n        result.push(\n          new CantBeFoundEvent(numberFoundEvent.getPosition(), i, this.name)\n        );\n      }\n    });\n    return result;\n  }\n}\n","import SudokuPosition from \"./SudokuPosition\";\nimport SudokuEventType from \"./SudokuEventType\";\nimport SudokuNumber from \"./SudokuNumber\";\n\nexport default class NumberFoundEvent {\n  readonly type = SudokuEventType.NUMBER_FOUND;\n  readonly position: SudokuPosition;\n  readonly number: SudokuNumber;\n  readonly from: string;\n\n  constructor(position: SudokuPosition, number: SudokuNumber, from: string) {\n    this.position = position;\n    this.number = number;\n    this.from = from;\n  }\n\n  getNumber() {\n    return this.number;\n  }\n\n  getPosition() {\n    return this.position;\n  }\n\n  getFrom() {\n    return this.from;\n  }\n}\n","import SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport CantBe2NumberFound from \"./CantBe2NumberFound\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\nimport SudokuYCoordinate from \"../../sudoku/SudokuYCoordinate\";\n\nexport default class OnlyOnePlaceHorizontalLine implements CantBe2NumberFound {\n  /**\n   * Es wird für jede Zeile(0-8) für jede Zahl(1-9) gespeichert, wo sie nicht hin darf.\n   */\n  private memory: Map<number, Map<SudokuNumber, Array<SudokuPosition>>>;\n  private readonly name = \"OnlyOnePlaceHorizontalLine\";\n\n  constructor() {\n    this.memory = OnlyOnePlaceHorizontalLine.initMemory();\n  }\n\n  private static initMemory() {\n    const memory = new Map<number, Map<SudokuNumber, Array<SudokuPosition>>>();\n    const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\n    for (let x: number = 0; x < 9; x++) {\n      let map1 = new Map<SudokuNumber, Array<SudokuPosition>>();\n      numbers.forEach(i => {\n        map1.set(i, []);\n      });\n      memory.set(x, map1);\n    }\n    return memory;\n  }\n\n  finderLogic(cantBes: Array<CantBeFoundEvent>): Array<NumberFoundEvent> {\n    const result: Array<NumberFoundEvent> = [];\n    cantBes.forEach(cantBe => {\n      const canBeForNumberInLine =\n        // @ts-ignore\n        this.memory\n          .get(cantBe.getPosition().getXCoordinate())\n          .get(cantBe.getNumber()) || []; // TODO handle undefine\n      if (\n        !canBeForNumberInLine.find(\n          it =>\n            it.getXCoordinate() === cantBe.getPosition().getXCoordinate() &&\n            it.getYCoordinate() === cantBe.getPosition().getYCoordinate()\n        )\n      ) {\n        canBeForNumberInLine.push(cantBe.getPosition());\n        if (canBeForNumberInLine.length === 8) {\n          result.push(\n            new NumberFoundEvent(\n              OnlyOnePlaceHorizontalLine.onlyPossiblePosition(\n                canBeForNumberInLine\n              ),\n              cantBe.getNumber(),\n              this.name\n            )\n          );\n        }\n      }\n    });\n    return result;\n  }\n\n  reset() {\n    this.memory = OnlyOnePlaceHorizontalLine.initMemory();\n  }\n\n  private static onlyPossiblePosition(\n    canBeForNumberInLine: SudokuPosition[]\n  ): SudokuPosition {\n    const yCoordinates: SudokuYCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n    for (let i = 0; i < yCoordinates.length; i++) {\n      let yCoordinate = yCoordinates[i];\n      if (\n        !canBeForNumberInLine.find(it => it.getYCoordinate() === yCoordinate)\n      ) {\n        return new SudokuPosition(\n          canBeForNumberInLine[0].getXCoordinate(),\n          yCoordinate\n        );\n      }\n    }\n    throw new Error(\"should not happen\");\n  }\n}\n","import SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport CantBe2NumberFound from \"./CantBe2NumberFound\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\nimport SudokuXCoordinate from \"../../sudoku/SudokuXCoordinate\";\n\nexport default class OnlyOnePlaceVerticalLine implements CantBe2NumberFound {\n  /**\n   * Es wird für jede Reihe(0-8) für jede Zahl(1-9) gespeichert, wo sie nicht hin darf.\n   */\n  speicher: Map<number, Map<SudokuNumber, Array<SudokuPosition>>>;\n  readonly name = \"OnlyOnePlaceVerticalLine\";\n\n  constructor() {\n    this.speicher = OnlyOnePlaceVerticalLine.initSpeicher();\n  }\n\n  static initSpeicher() {\n    const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\n    const speicher = new Map<\n      number,\n      Map<SudokuNumber, Array<SudokuPosition>>\n    >();\n    for (let x: number = 0; x < 9; x++) {\n      let map1 = new Map<SudokuNumber, Array<SudokuPosition>>();\n      numbers.forEach(i => {\n        map1.set(i, []);\n      });\n      speicher.set(x, map1);\n    }\n    return speicher;\n  }\n\n  finderLogic(cantBes: Array<CantBeFoundEvent>): Array<NumberFoundEvent> {\n    const result: Array<NumberFoundEvent> = [];\n    cantBes.forEach(cantBe => {\n      const canBeForNumberInLine =\n        // @ts-ignore\n        this.speicher\n          .get(cantBe.getPosition().getYCoordinate())\n          .get(cantBe.getNumber()) || []; // TODO handle undefined\n      if (\n        !canBeForNumberInLine.find(\n          it =>\n            it.getXCoordinate() === cantBe.getPosition().getXCoordinate() &&\n            it.getYCoordinate() === cantBe.getPosition().getYCoordinate()\n        )\n      ) {\n        canBeForNumberInLine.push(cantBe.getPosition());\n        if (canBeForNumberInLine.length === 8) {\n          result.push(\n            new NumberFoundEvent(\n              OnlyOnePlaceVerticalLine.onlyPossiblePosition(\n                canBeForNumberInLine\n              ),\n              cantBe.getNumber(),\n              this.name\n            )\n          );\n        }\n      }\n    });\n    return result;\n  }\n\n  reset() {\n    this.speicher = OnlyOnePlaceVerticalLine.initSpeicher();\n  }\n\n  private static onlyPossiblePosition(\n    canBeForNumberInLine: SudokuPosition[]\n  ): SudokuPosition {\n    const xCoordinates: SudokuXCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n    for (let i = 0; i < xCoordinates.length; i++) {\n      let xCoordinate = xCoordinates[i];\n      if (\n        !canBeForNumberInLine.find(it => it.getXCoordinate() === xCoordinate)\n      ) {\n        return new SudokuPosition(\n          xCoordinate,\n          canBeForNumberInLine[0].getYCoordinate()\n        );\n      }\n    }\n    throw new Error(\"should not happen\");\n  }\n}\n","import SudokuBox from \"../../sudoku/SudokuBox\";\nimport SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport CantBe2NumberFound from \"./CantBe2NumberFound\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\n\nfunction samePosition(one: SudokuPosition, two: SudokuPosition) {\n  return (\n    one.getXCoordinate() === two.getXCoordinate() &&\n    one.getYCoordinate() === two.getYCoordinate()\n  );\n}\n\nexport default class OnlyOnePlaceBox implements CantBe2NumberFound {\n  /**\n   * Es wird für jede Box für jede Zahl(1-9) gespeichert, wo sie nicht hin darf.\n   */\n  private readonly memory: Map<\n    SudokuBox,\n    Map<SudokuNumber, Array<SudokuPosition>>\n  > = OnlyOnePlaceBox.init();\n  private readonly name = \"OnlyOnePlaceBox\";\n\n  private static init() {\n    const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    const memory = new Map<\n      SudokuBox,\n      Map<SudokuNumber, Array<SudokuPosition>>\n    >();\n    for (let x = 0; x < 3; x++) {\n      for (let y = 0; y < 3; y++) {\n        let map1 = new Map<SudokuNumber, Array<SudokuPosition>>();\n        numbers.forEach(i => {\n          map1.set(i, []);\n        });\n        memory.set(SudokuBox.create(x, y), map1);\n      }\n    }\n    return memory;\n  }\n\n  finderLogic(cantBes: Array<CantBeFoundEvent>) {\n    const results: NumberFoundEvent[] = [];\n    for (let info of cantBes) {\n      let position = info.getPosition();\n      let nTNumber = info.getNumber();\n      let box: SudokuBox = SudokuBox.createByPosition(position);\n\n      // @ts-ignore\n      const notHeres = this.memory.get(box).get(nTNumber);\n      if (notHeres && !notHeres.find(it => samePosition(position, it))) {\n        notHeres.push(position);\n        if (notHeres.length === 8) {\n          // @ts-ignore\n          for (let newPos of box.allSudokuPositionInThisBox()) {\n            if (!notHeres.find(it => samePosition(newPos, it))) {\n              results.push(new NumberFoundEvent(newPos, nTNumber, this.name)); //FIXME\n            }\n          }\n        }\n      }\n    }\n    return results;\n  }\n}\n","import CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport CantBe2NumberFound from \"./CantBe2NumberFound\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\n\nexport default class OnePositionFinder implements CantBe2NumberFound {\n  notThisNumber: boolean[][][] = OnePositionFinder.createBoolean3dArray();\n  name = \"OnePositionFinder\";\n\n  finderLogic(cantBes: CantBeFoundEvent[]) {\n    const results: NumberFoundEvent[] = [];\n    for (let event of cantBes) {\n      const position = event.getPosition();\n      const nTNumber = event.getNumber();\n      this.notThisNumber[position.getXCoordinate()][position.getYCoordinate()][\n        nTNumber\n      ] = true;\n\n      let anzFalse = 0;\n      let lastFalsePosition: SudokuNumber | null = null;\n      const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\n      numbers.forEach(i => {\n        if (\n          !this.notThisNumber[position.getXCoordinate()][\n            position.getYCoordinate()\n          ][i]\n        ) {\n          anzFalse++;\n          lastFalsePosition = i;\n        }\n      });\n      if (anzFalse === 1 && lastFalsePosition !== null) {\n        results.push(\n          new NumberFoundEvent(position, lastFalsePosition, this.name)\n        );\n      }\n    }\n    return results;\n  }\n\n  private static createBoolean3dArray() {\n    const array3d: boolean[][][] = [];\n\n    for (let i = 0; i < 9; i++) {\n      array3d[i] = [];\n      for (let j = 0; j < 9; j++) {\n        array3d[i][j] = [];\n        for (let k = 0; k < 9; k++) {\n          array3d[i][j][k] = false;\n        }\n      }\n    }\n\n    return array3d;\n  }\n}\n","import SudokuEventType from \"./SudokuEventType\";\nimport NumberFoundEvent from \"./NumberFoundEvent\";\n\nexport default class EventFilter {\n  private numberFound: number[][] = [[], [], [], [], [], [], [], [], []];\n\n  removeAlreadySeen(toFilter: NumberFoundEvent[]) {\n    const filtered = [];\n\n    for (const numberFoundEvent of toFilter) {\n      if (numberFoundEvent.type === SudokuEventType.NUMBER_FOUND) {\n        if (\n          !this.numberFound[numberFoundEvent.getPosition().getXCoordinate()][\n            numberFoundEvent.getPosition().getYCoordinate()\n          ]\n        ) {\n          this.numberFound[numberFoundEvent.getPosition().getXCoordinate()][\n            numberFoundEvent.getPosition().getYCoordinate()\n          ] = numberFoundEvent.getNumber();\n          filtered.push(numberFoundEvent);\n        }\n        // TODO validate number in case of alerdy seen\n      } else {\n        // filter CANT BES\n        filtered.push(numberFoundEvent);\n      }\n    }\n    return filtered;\n  }\n}\n","import BoxCantBeRule from \"../finder/numberFound2cantBe/BoxCantBeRule\";\nimport HorizontalCantBeRule from \"../finder/numberFound2cantBe/HorizontalCantBeRule\";\nimport VerticalCantBeRule from \"../finder/numberFound2cantBe/VerticalCantBeRule\";\nimport OnePositionCantBeRule from \"../finder/numberFound2cantBe/OnePositionCantBeRule\";\nimport OnlyOnePlaceHorizontalLine from \"../finder/cantBe2NumberFound/OnlyOnePlaceHorizontalLine\";\nimport OnlyOnePlaceVerticalLine from \"../finder/cantBe2NumberFound/OnlyOnePlaceVerticalLine\";\nimport OnlyOnePlaceBox from \"../finder/cantBe2NumberFound/OnlyOnePlaceBox\";\nimport OnePositionFinder from \"../finder/cantBe2NumberFound/OnePositionFinder\";\nimport EventFilter from \"./EventFilter\";\nimport CantBeFoundEvent from \"./CantBeFoundEvent\";\nimport NumberFound2CantBe from \"../finder/numberFound2cantBe/NumberFound2CantBe\";\nimport NumberFoundEvent from \"./NumberFoundEvent\";\nimport CantBe2NumberFound from \"../finder/cantBe2NumberFound/CantBe2NumberFound\";\n\nlet numberFound2cantBeRules: NumberFound2CantBe[] = [\n  new BoxCantBeRule(),\n  new HorizontalCantBeRule(),\n  new VerticalCantBeRule(),\n  new OnePositionCantBeRule()\n];\n\nlet cantBe2NumberFound: CantBe2NumberFound[] = [\n  new OnlyOnePlaceHorizontalLine(),\n  new OnlyOnePlaceVerticalLine(),\n  new OnlyOnePlaceBox(),\n  new OnePositionFinder()\n];\n\nlet eventFilter = new EventFilter();\n\nexport default class RuleOrchestration {\n  handleGivenNumber(\n    numberFoundEvent: NumberFoundEvent,\n    postMessage: (e: CantBeFoundEvent | NumberFoundEvent) => void\n  ) {\n    let foundNumbers = [numberFoundEvent];\n    do {\n      let cantBeRulesResults: CantBeFoundEvent[] = [];\n      for (const rule of numberFound2cantBeRules) {\n        for (const foundNumber of foundNumbers) {\n          cantBeRulesResults = cantBeRulesResults.concat(\n            rule.finderLogic(foundNumber)\n          );\n        }\n      }\n      cantBeRulesResults.forEach(it => {\n        postMessage(it);\n      });\n\n      foundNumbers = [];\n      for (const rule of cantBe2NumberFound) {\n        foundNumbers = foundNumbers.concat(\n          rule.finderLogic(cantBeRulesResults)\n        );\n      }\n      foundNumbers = eventFilter.removeAlreadySeen(foundNumbers);\n      foundNumbers.forEach(foundNumbers => {\n        postMessage(foundNumbers);\n      });\n    } while (foundNumbers.length > 0);\n  }\n}\n","import SudokuPosition from \"./sudoku/SudokuPosition\";\nimport RuleOrchestration from \"./sudoku/RuleOrchestration\";\nimport NumberFoundEvent from \"./sudoku/NumberFoundEvent\";\n\nlet ruleOrchestration = new RuleOrchestration();\n\n// eslint-disable-next-line no-restricted-globals\naddEventListener(\"message\", ({ data }) => {\n  console.log(\"worker got message\", data);\n\n  let sudokuEvent = new NumberFoundEvent(\n    new SudokuPosition(data.field[0], data.field[1]),\n    data.value,\n    \"USER\"\n  );\n  ruleOrchestration.handleGivenNumber(sudokuEvent, postMessage);\n});\n"],"sourceRoot":""}