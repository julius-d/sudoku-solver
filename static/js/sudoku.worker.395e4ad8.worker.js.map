{"version":3,"file":"static/js/sudoku.worker.395e4ad8.worker.js","mappings":"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","sources":["sudoku/SudokuPosition.ts","sudoku/SudokuBox.ts","sudoku/SudokuEventType.ts","sudoku/CantBeFoundEvent.ts","finder/numberFound2cantBe/BoxCantBeRule.ts","finder/numberFound2cantBe/HorizontalCantBeRule.ts","finder/numberFound2cantBe/VerticalCantBeRule.ts","finder/numberFound2cantBe/OnePositionCantBeRule.ts","sudoku/NumberFoundEvent.ts","finder/cantBe2NumberFound/OnlyOnePlaceHorizontalLine.ts","finder/cantBe2NumberFound/OnlyOnePlaceVerticalLine.ts","finder/cantBe2NumberFound/OnlyOnePlaceBox.ts","finder/cantBe2NumberFound/OnePositionFinder.ts","sudoku/EventFilter.ts","finder/cantBe2cantBe/Utils.ts","finder/cantBe2cantBe/PairBasedExcluderInVerticalLine.ts","finder/cantBe2cantBe/PairBasedExcluderInHorizontalLine.ts","sudoku.worker.js","sudoku/RuleOrchestration.ts"],"sourcesContent":["import SudokuXCoordinate from \"./SudokuXCoordinate\";\nimport SudokuYCoordinate from \"./SudokuYCoordinate\";\n\nexport default class SudokuPosition {\n  readonly xCoordinate: SudokuXCoordinate;\n  readonly yCoordinate: SudokuYCoordinate;\n\n  private static allInstances: SudokuPosition[][] = SudokuPosition.createAll();\n\n  private static createAll() {\n    const allXCoordinates: SudokuXCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n    const allYCoordinates: SudokuYCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n    const all: SudokuPosition[][] = [[], [], [], [], [], [], [], [], []];\n    allXCoordinates.forEach((x) => {\n      allYCoordinates.forEach((y) => {\n        all[x][y] = new SudokuPosition(x, y);\n      });\n    });\n    return all;\n  }\n\n  public static of(\n    xCoordinate: SudokuXCoordinate,\n    yCoordinate: SudokuYCoordinate,\n  ): SudokuPosition {\n    return SudokuPosition.allInstances[xCoordinate][yCoordinate];\n  }\n\n  private constructor(\n    xCoordinate: SudokuXCoordinate,\n    yCoordinate: SudokuYCoordinate,\n  ) {\n    this.xCoordinate = xCoordinate;\n    this.yCoordinate = yCoordinate;\n  }\n\n  getXCoordinate() {\n    return this.xCoordinate;\n  }\n\n  getYCoordinate() {\n    return this.yCoordinate;\n  }\n\n  toString() {\n    return \"Pos: [\" + this.xCoordinate + \",\" + this.yCoordinate + \"]\";\n  }\n\n  valueOf() {\n    return \"[\" + this.xCoordinate + \"][\" + this.yCoordinate + \"]\";\n  }\n}\n","import SudokuPosition from \"./SudokuPosition\";\nimport SudokuYCoordinate from \"./SudokuYCoordinate\";\nimport SudokuXCoordinate from \"./SudokuXCoordinate\";\n\ntype BoxCoordinate = 0 | 1 | 2;\n\nexport default class SudokuBox {\n  private readonly x: BoxCoordinate;\n  private readonly y: BoxCoordinate;\n\n  private static allInstances: SudokuBox[][] = SudokuBox.createAll();\n\n  private constructor(x: BoxCoordinate, y: BoxCoordinate) {\n    if (x < 0 || y < 0 || x > 2 || y > 2) {\n      throw new Error(\"illegal argument x:\" + x + \" y: \" + y);\n    }\n    this.x = x;\n    this.y = y;\n  }\n\n  getX() {\n    return this.x;\n  }\n\n  getY() {\n    return this.y;\n  }\n\n  getAll() {\n    return SudokuBox.allInstances;\n  }\n\n  private static createAll() {\n    const allBoxCoordinates: BoxCoordinate[] = [0, 1, 2];\n    const all: SudokuBox[][] = [[], [], []];\n    allBoxCoordinates.forEach((x) => {\n      allBoxCoordinates.forEach((y) => {\n        all[x][y] = new SudokuBox(x, y);\n      });\n    });\n    return all;\n  }\n\n  static createByPosition(postion: SudokuPosition) {\n    const x = postion.getXCoordinate();\n    const y = postion.getYCoordinate();\n    const boxXCoordinate = this.boxCoordinateFor(x);\n    const boxYCoordinate = this.boxCoordinateFor(y);\n    return this.allInstances[boxXCoordinate][boxYCoordinate];\n  }\n\n  private static boxCoordinateFor(\n    coordinate: SudokuXCoordinate | SudokuYCoordinate,\n  ) {\n    if (coordinate === 0 || coordinate === 1 || coordinate === 2) {\n      return 0;\n    } else if (coordinate === 3 || coordinate === 4 || coordinate === 5) {\n      return 1;\n    } else {\n      return 2;\n    }\n  }\n\n  private static sudokuCoordinateFor(\n    coordinate: BoxCoordinate,\n  ): Array<SudokuXCoordinate | SudokuYCoordinate> {\n    if (coordinate === 0) {\n      return [0, 1, 2];\n    } else if (coordinate === 1) {\n      return [3, 4, 5];\n    } else {\n      return [6, 7, 8];\n    }\n  }\n\n  static create(x: number, y: number) {\n    return this.allInstances[x][y];\n  }\n\n  allSudokuPositionInThisBox() {\n    let result: SudokuPosition[] = [];\n    SudokuBox.sudokuCoordinateFor(this.y).forEach((yC) => {\n      SudokuBox.sudokuCoordinateFor(this.x).forEach((xC) => {\n        const position = SudokuPosition.of(xC, yC);\n        result.push(position);\n      });\n    });\n    return result;\n  }\n\n  toString() {\n    return \"Box: [\" + this.x + \",\" + this.y + \"]\";\n  }\n}\n","enum SudokuEventType {\n  CANT_BE,\n  NUMBER_FOUND,\n}\nexport default SudokuEventType;\n","import SudokuPosition from \"./SudokuPosition\";\nimport SudokuEventType from \"./SudokuEventType\";\nimport SudokuNumber from \"./SudokuNumber\";\n\nexport default class CantBeFoundEvent {\n  readonly type: SudokuEventType = SudokuEventType.CANT_BE;\n  readonly position: SudokuPosition;\n  readonly number: SudokuNumber;\n  readonly from: string;\n\n  constructor(postion: SudokuPosition, number: SudokuNumber, from: string) {\n    this.position = postion;\n    this.number = number;\n    this.from = from;\n  }\n\n  getNumber() {\n    return this.number;\n  }\n\n  getPosition() {\n    return this.position;\n  }\n\n  getFrom() {\n    return this.from;\n  }\n}\n","import SudokuBox from \"../../sudoku/SudokuBox\";\nimport CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport NumberFound2CantBe from \"./NumberFound2CantBe\";\n\nexport default class BoxCantBeRule implements NumberFound2CantBe {\n  private readonly ruleName = \"BoxCantBeRule\";\n\n  finderLogic(numberFoundEvent: NumberFoundEvent) {\n    const result = [];\n    const box = SudokuBox.createByPosition(numberFoundEvent.getPosition());\n\n    for (let position of box.allSudokuPositionInThisBox()) {\n      if (\n        position.getYCoordinate() !==\n          numberFoundEvent.getPosition().getYCoordinate() ||\n        position.getXCoordinate() !==\n          numberFoundEvent.getPosition().getXCoordinate()\n      ) {\n        result.push(\n          new CantBeFoundEvent(\n            position,\n            numberFoundEvent.getNumber(),\n            this.ruleName,\n          ),\n        );\n      }\n    }\n\n    return result;\n  }\n}\n","import CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport NumberFound2CantBe from \"./NumberFound2CantBe\";\nimport SudokuYCoordinate from \"../../sudoku/SudokuYCoordinate\";\n\nexport default class HorizontalCantBeRule implements NumberFound2CantBe {\n  private readonly name = \"HorizontalCantBeRule\";\n\n  finderLogic(numberFoundEvent: NumberFoundEvent) {\n    const result: CantBeFoundEvent[] = [];\n    const yCoordinates: SudokuYCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n\n    let xk = numberFoundEvent.getPosition().getXCoordinate();\n    yCoordinates.forEach((yk) => {\n      if (yk !== numberFoundEvent.getPosition().getYCoordinate()) {\n        result.push(\n          new CantBeFoundEvent(\n            SudokuPosition.of(xk, yk),\n            numberFoundEvent.getNumber(),\n            this.name,\n          ),\n        );\n      }\n    });\n\n    return result;\n  }\n}\n","import CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport NumberFound2CantBe from \"./NumberFound2CantBe\";\nimport SudokuXCoordinate from \"../../sudoku/SudokuXCoordinate\";\n\nexport default class VerticalCantBeRule implements NumberFound2CantBe {\n  private readonly name = \"VerticalCantBeRule\";\n\n  finderLogic(numberFoundEvent: NumberFoundEvent) {\n    const result: CantBeFoundEvent[] = [];\n    const xCoordinates: SudokuXCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n\n    let yk = numberFoundEvent.getPosition().getYCoordinate();\n    xCoordinates.forEach((xk) => {\n      if (xk !== numberFoundEvent.getPosition().getXCoordinate()) {\n        result.push(\n          new CantBeFoundEvent(\n            SudokuPosition.of(xk, yk),\n            numberFoundEvent.getNumber(),\n            this.name,\n          ),\n        );\n      }\n    });\n    return result;\n  }\n}\n","import CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport NumberFound2CantBe from \"./NumberFound2CantBe\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\n\nexport default class OnePositionCantBeRule implements NumberFound2CantBe {\n  private readonly name = \"OnePositionCantBeRule\";\n\n  finderLogic(numberFoundEvent: NumberFoundEvent) {\n    const result: CantBeFoundEvent[] = [];\n    const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    numbers.forEach((i) => {\n      if (i !== numberFoundEvent.getNumber()) {\n        result.push(\n          new CantBeFoundEvent(numberFoundEvent.getPosition(), i, this.name),\n        );\n      }\n    });\n    return result;\n  }\n}\n","import SudokuPosition from \"./SudokuPosition\";\nimport SudokuEventType from \"./SudokuEventType\";\nimport SudokuNumber from \"./SudokuNumber\";\n\nexport default class NumberFoundEvent {\n  readonly type = SudokuEventType.NUMBER_FOUND;\n  readonly position: SudokuPosition;\n  readonly number: SudokuNumber;\n  readonly from: string;\n\n  constructor(position: SudokuPosition, number: SudokuNumber, from: string) {\n    this.position = position;\n    this.number = number;\n    this.from = from;\n  }\n\n  getNumber() {\n    return this.number;\n  }\n\n  getPosition() {\n    return this.position;\n  }\n\n  getFrom() {\n    return this.from;\n  }\n}\n","import SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport CantBe2NumberFound from \"./CantBe2NumberFound\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\nimport SudokuYCoordinate from \"../../sudoku/SudokuYCoordinate\";\n\nexport default class OnlyOnePlaceHorizontalLine implements CantBe2NumberFound {\n  /**\n   * Es wird für jede Zeile(0-8) für jede Zahl(1-9) gespeichert, wo sie nicht hin darf.\n   */\n  private readonly memory: Map<\n    number,\n    Map<SudokuNumber, Array<SudokuPosition>>\n  >;\n  private readonly name = \"OnlyOnePlaceHorizontalLine\";\n\n  constructor() {\n    this.memory = OnlyOnePlaceHorizontalLine.initMemory();\n  }\n\n  private static initMemory() {\n    const memory = new Map<number, Map<SudokuNumber, Array<SudokuPosition>>>();\n    const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\n    for (let x: number = 0; x < 9; x++) {\n      let map1 = new Map<SudokuNumber, Array<SudokuPosition>>();\n      numbers.forEach((i) => {\n        map1.set(i, []);\n      });\n      memory.set(x, map1);\n    }\n    return memory;\n  }\n\n  finderLogic(cantBes: Array<CantBeFoundEvent>): Array<NumberFoundEvent> {\n    const result: Array<NumberFoundEvent> = [];\n    cantBes.forEach((cantBe) => {\n      const canBeForNumberInLine =\n        this.memory\n          .get(cantBe.getPosition().getXCoordinate())\n          ?.get(cantBe.getNumber()) || []; // TODO handle undefine\n      if (\n        !canBeForNumberInLine.find(\n          (it) =>\n            it.getXCoordinate() === cantBe.getPosition().getXCoordinate() &&\n            it.getYCoordinate() === cantBe.getPosition().getYCoordinate(),\n        )\n      ) {\n        canBeForNumberInLine.push(cantBe.getPosition());\n        if (canBeForNumberInLine.length === 8) {\n          result.push(\n            new NumberFoundEvent(\n              OnlyOnePlaceHorizontalLine.onlyPossiblePosition(\n                canBeForNumberInLine,\n              ),\n              cantBe.getNumber(),\n              this.name,\n            ),\n          );\n        }\n      }\n    });\n    return result;\n  }\n\n  private static onlyPossiblePosition(\n    canBeForNumberInLine: SudokuPosition[],\n  ): SudokuPosition {\n    const yCoordinates: SudokuYCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n    for (let i = 0; i < yCoordinates.length; i++) {\n      let yCoordinate = yCoordinates[i];\n      if (\n        !canBeForNumberInLine.find((it) => it.getYCoordinate() === yCoordinate)\n      ) {\n        return SudokuPosition.of(\n          canBeForNumberInLine[0].getXCoordinate(),\n          yCoordinate,\n        );\n      }\n    }\n    throw new Error(\"should not happen\");\n  }\n}\n","import SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport CantBe2NumberFound from \"./CantBe2NumberFound\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\nimport SudokuXCoordinate from \"../../sudoku/SudokuXCoordinate\";\nimport SudokuYCoordinate from \"../../sudoku/SudokuYCoordinate\";\n\nexport default class OnlyOnePlaceVerticalLine implements CantBe2NumberFound {\n  /**\n   * Es wird für jede Reihe(0-8) für jede Zahl(1-9) gespeichert, wo sie nicht hin darf.\n   */\n  private readonly memory: Map<\n    SudokuYCoordinate,\n    Map<SudokuNumber, Array<SudokuPosition>>\n  >;\n  private readonly name = \"OnlyOnePlaceVerticalLine\";\n\n  constructor() {\n    this.memory = OnlyOnePlaceVerticalLine.initMemory();\n  }\n\n  static initMemory() {\n    const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    const sudokuYCoordinates: SudokuYCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n\n    const memory = new Map<\n      SudokuYCoordinate,\n      Map<SudokuNumber, Array<SudokuPosition>>\n    >();\n    sudokuYCoordinates.forEach((x) => {\n      let map1 = new Map<SudokuNumber, Array<SudokuPosition>>();\n      numbers.forEach((i) => {\n        map1.set(i, []);\n      });\n      memory.set(x, map1);\n    });\n    return memory;\n  }\n\n  finderLogic(cantBes: Array<CantBeFoundEvent>): Array<NumberFoundEvent> {\n    const result: Array<NumberFoundEvent> = [];\n    cantBes.forEach((cantBe) => {\n      const canBeForNumberInLine =\n        this.memory\n          .get(cantBe.getPosition().getYCoordinate())\n          ?.get(cantBe.getNumber()) || []; // TODO handle undefined\n      if (\n        !canBeForNumberInLine.find(\n          (it) =>\n            it.getXCoordinate() === cantBe.getPosition().getXCoordinate() &&\n            it.getYCoordinate() === cantBe.getPosition().getYCoordinate(),\n        )\n      ) {\n        canBeForNumberInLine.push(cantBe.getPosition());\n        if (canBeForNumberInLine.length === 8) {\n          result.push(\n            new NumberFoundEvent(\n              OnlyOnePlaceVerticalLine.onlyPossiblePosition(\n                canBeForNumberInLine,\n              ),\n              cantBe.getNumber(),\n              this.name,\n            ),\n          );\n        }\n      }\n    });\n    return result;\n  }\n\n  private static onlyPossiblePosition(\n    canBeForNumberInLine: SudokuPosition[],\n  ): SudokuPosition {\n    const xCoordinates: SudokuXCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n    for (let i = 0; i < xCoordinates.length; i++) {\n      let xCoordinate = xCoordinates[i];\n      if (\n        !canBeForNumberInLine.find((it) => it.getXCoordinate() === xCoordinate)\n      ) {\n        return SudokuPosition.of(\n          xCoordinate,\n          canBeForNumberInLine[0].getYCoordinate(),\n        );\n      }\n    }\n    throw new Error(\"should not happen\");\n  }\n}\n","import SudokuBox from \"../../sudoku/SudokuBox\";\nimport SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport CantBe2NumberFound from \"./CantBe2NumberFound\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\n\nfunction samePosition(one: SudokuPosition, two: SudokuPosition) {\n  return (\n    one.getXCoordinate() === two.getXCoordinate() &&\n    one.getYCoordinate() === two.getYCoordinate()\n  );\n}\n\nexport default class OnlyOnePlaceBox implements CantBe2NumberFound {\n  /**\n   * Es wird für jede Box für jede Zahl(1-9) gespeichert, wo sie nicht hin darf.\n   */\n  private readonly memory: Map<\n    SudokuBox,\n    Map<SudokuNumber, Array<SudokuPosition>>\n  > = OnlyOnePlaceBox.init();\n  private readonly name = \"OnlyOnePlaceBox\";\n\n  private static init() {\n    const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    const memory = new Map<\n      SudokuBox,\n      Map<SudokuNumber, Array<SudokuPosition>>\n    >();\n    for (let x = 0; x < 3; x++) {\n      for (let y = 0; y < 3; y++) {\n        let map1 = new Map<SudokuNumber, Array<SudokuPosition>>();\n        numbers.forEach((i) => {\n          map1.set(i, []);\n        });\n        memory.set(SudokuBox.create(x, y), map1);\n      }\n    }\n    return memory;\n  }\n\n  finderLogic(cantBes: Array<CantBeFoundEvent>) {\n    const results: NumberFoundEvent[] = [];\n    for (let info of cantBes) {\n      let position = info.getPosition();\n      let nTNumber = info.getNumber();\n      let box: SudokuBox = SudokuBox.createByPosition(position);\n\n      const notHeres = this.memory.get(box)?.get(nTNumber);\n      if (notHeres && !notHeres.find((it) => samePosition(position, it))) {\n        notHeres.push(position);\n        if (notHeres.length === 8) {\n          box.allSudokuPositionInThisBox().forEach((newPos) => {\n            if (!notHeres.find((it) => samePosition(newPos, it))) {\n              results.push(new NumberFoundEvent(newPos, nTNumber, this.name)); //FIXME\n            }\n          });\n        }\n      }\n    }\n    return results;\n  }\n}\n","import CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport CantBe2NumberFound from \"./CantBe2NumberFound\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\n\nexport default class OnePositionFinder implements CantBe2NumberFound {\n  private readonly notThisNumber: boolean[][][] =\n    OnePositionFinder.createBoolean3dArray();\n  private readonly name = \"OnePositionFinder\";\n\n  finderLogic(cantBes: CantBeFoundEvent[]) {\n    const results: NumberFoundEvent[] = [];\n    for (let event of cantBes) {\n      const position = event.getPosition();\n      const nTNumber = event.getNumber();\n      this.notThisNumber[position.getXCoordinate()][position.getYCoordinate()][\n        nTNumber\n      ] = true;\n\n      let anzFalse = 0;\n      let lastFalsePosition: SudokuNumber | null = null;\n      const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\n      numbers.forEach((i) => {\n        if (\n          !this.notThisNumber[position.getXCoordinate()][\n            position.getYCoordinate()\n          ][i]\n        ) {\n          anzFalse++;\n          lastFalsePosition = i;\n        }\n      });\n      if (anzFalse === 1 && lastFalsePosition !== null) {\n        results.push(\n          new NumberFoundEvent(position, lastFalsePosition, this.name),\n        );\n      }\n    }\n    return results;\n  }\n\n  private static createBoolean3dArray() {\n    const array3d: boolean[][][] = [];\n\n    for (let i = 0; i < 9; i++) {\n      array3d[i] = [];\n      for (let j = 0; j < 9; j++) {\n        array3d[i][j] = [];\n        for (let k = 0; k < 9; k++) {\n          array3d[i][j][k] = false;\n        }\n      }\n    }\n\n    return array3d;\n  }\n}\n","import SudokuEventType from \"./SudokuEventType\";\nimport NumberFoundEvent from \"./NumberFoundEvent\";\n\nexport default class EventFilter {\n  private numberFound: number[][] = [[], [], [], [], [], [], [], [], []];\n\n  removeAlreadySeen(toFilter: NumberFoundEvent[]) {\n    const filtered = [];\n\n    for (const numberFoundEvent of toFilter) {\n      if (numberFoundEvent.type === SudokuEventType.NUMBER_FOUND) {\n        if (\n          !this.numberFound[numberFoundEvent.getPosition().getXCoordinate()][\n            numberFoundEvent.getPosition().getYCoordinate()\n          ]\n        ) {\n          this.numberFound[numberFoundEvent.getPosition().getXCoordinate()][\n            numberFoundEvent.getPosition().getYCoordinate()\n          ] = numberFoundEvent.getNumber();\n          filtered.push(numberFoundEvent);\n        }\n        // TODO validate number in case of alerdy seen\n      } else {\n        // filter CANT BES\n        filtered.push(numberFoundEvent);\n      }\n    }\n    return filtered;\n  }\n}\n","import SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport SudokuBox from \"../../sudoku/SudokuBox\";\nimport SudokuYCoordinate from \"../../sudoku/SudokuYCoordinate\";\nimport SudokuXCoordinate from \"../../sudoku/SudokuXCoordinate\";\n\nexport function getAllPossiblePositions(\n  notHeres: SudokuPosition[],\n  box: SudokuBox,\n): SudokuPosition[] {\n  return box\n    .allSudokuPositionInThisBox()\n    .filter((pos) => notHeres.indexOf(pos) < 0);\n}\n\nexport function getYCoordinatesOf(\n  possiblePositions: SudokuPosition[],\n): SudokuYCoordinate[] {\n  return distinct(possiblePositions.map((pos) => pos.getYCoordinate()));\n}\n\nexport function getXCoordinatesOf(\n  possiblePositions: SudokuPosition[],\n): SudokuXCoordinate[] {\n  return distinct(possiblePositions.map((pos) => pos.getXCoordinate()));\n}\n\nfunction distinct<T>(list: T[]): T[] {\n  return list.filter((e, i, self) => i === self.indexOf(e));\n}\n","import SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\nimport SudokuXCoordinate from \"../../sudoku/SudokuXCoordinate\";\nimport SudokuYCoordinate from \"../../sudoku/SudokuYCoordinate\";\nimport SudokuBox from \"../../sudoku/SudokuBox\";\nimport CantBe2CantBe from \"./CantBe2CantBe\";\nimport { getAllPossiblePositions, getYCoordinatesOf } from \"./Utils\";\n\nfunction samePosition(one: SudokuPosition, two: SudokuPosition) {\n  return (\n    one.getXCoordinate() === two.getXCoordinate() &&\n    one.getYCoordinate() === two.getYCoordinate()\n  );\n}\n\nexport default class PairBasedExcluderInVerticalLine implements CantBe2CantBe {\n  /**\n   * Es wird für jede Box für jede Zahl(1-9) gespeichert, wo sie nicht hin darf.\n   */\n  private readonly memory: Map<\n    SudokuBox,\n    Map<SudokuNumber, Array<SudokuPosition>>\n  > = PairBasedExcluderInVerticalLine.init();\n  private readonly name = \"PairBasedExcluderInVerticalLine\";\n\n  private static init() {\n    const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    const memory = new Map<\n      SudokuBox,\n      Map<SudokuNumber, Array<SudokuPosition>>\n    >();\n    for (let x = 0; x < 3; x++) {\n      for (let y = 0; y < 3; y++) {\n        let map1 = new Map<SudokuNumber, Array<SudokuPosition>>();\n        numbers.forEach((i) => {\n          map1.set(i, []);\n        });\n        memory.set(SudokuBox.create(x, y), map1);\n      }\n    }\n    return memory;\n  }\n\n  finderLogic(cantBes: Array<CantBeFoundEvent>): CantBeFoundEvent[] {\n    const results: CantBeFoundEvent[] = [];\n    for (let info of cantBes) {\n      let position = info.getPosition();\n      let nTNumber = info.getNumber();\n      let box: SudokuBox = SudokuBox.createByPosition(position);\n\n      const notHeres = this.memory.get(box)?.get(nTNumber);\n      if (notHeres && !notHeres.find((it) => samePosition(position, it))) {\n        notHeres.push(position);\n        if (notHeres.length >= 6 && notHeres.length <= 7) {\n          const possiblePositions: SudokuPosition[] = getAllPossiblePositions(\n            notHeres,\n            box,\n          );\n          const yCoordinatesOfPossiblePositions: SudokuYCoordinate[] =\n            getYCoordinatesOf(possiblePositions);\n          if (yCoordinatesOfPossiblePositions.length === 1) {\n            // TADA gefunden\n            const newCantBeFoundEvent: CantBeFoundEvent[] =\n              generateCantBeFoundEventFor(\n                yCoordinatesOfPossiblePositions[0],\n                nTNumber,\n                box,\n              );\n            results.push(...newCantBeFoundEvent);\n          }\n        }\n      }\n    }\n    return results;\n  }\n}\n\nfunction generateCantBeFoundEventFor(\n  yCoordinatesOfPossiblePositions: SudokuYCoordinate,\n  nTNumber: SudokuNumber,\n  box: SudokuBox,\n): CantBeFoundEvent[] {\n  const allXCoords: SudokuXCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n  return allXCoords\n    .map((xCoordinate) =>\n      SudokuPosition.of(xCoordinate, yCoordinatesOfPossiblePositions),\n    )\n    .filter((pos) => box.allSudokuPositionInThisBox().indexOf(pos) < 0)\n    .map(\n      (pos) =>\n        new CantBeFoundEvent(\n          pos,\n          nTNumber,\n          PairBasedExcluderInVerticalLine.name,\n        ),\n    );\n}\n","import SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\nimport SudokuXCoordinate from \"../../sudoku/SudokuXCoordinate\";\nimport SudokuYCoordinate from \"../../sudoku/SudokuYCoordinate\";\nimport SudokuBox from \"../../sudoku/SudokuBox\";\nimport CantBe2CantBe from \"./CantBe2CantBe\";\nimport { getAllPossiblePositions, getXCoordinatesOf } from \"./Utils\";\n\nfunction samePosition(one: SudokuPosition, two: SudokuPosition) {\n  return (\n    one.getXCoordinate() === two.getXCoordinate() &&\n    one.getYCoordinate() === two.getYCoordinate()\n  );\n}\n\nexport default class PairBasedExcluderInHorizontalLine\n  implements CantBe2CantBe\n{\n  /**\n   * Es wird für jede Box für jede Zahl(1-9) gespeichert, wo sie nicht hin darf.\n   */\n  private readonly memory: Map<\n    SudokuBox,\n    Map<SudokuNumber, Array<SudokuPosition>>\n  > = PairBasedExcluderInHorizontalLine.init();\n  private readonly name = \"PairBasedExcluderInHorizontalLine\";\n\n  private static init() {\n    const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    const memory = new Map<\n      SudokuBox,\n      Map<SudokuNumber, Array<SudokuPosition>>\n    >();\n    for (let x = 0; x < 3; x++) {\n      for (let y = 0; y < 3; y++) {\n        let map1 = new Map<SudokuNumber, Array<SudokuPosition>>();\n        numbers.forEach((i) => {\n          map1.set(i, []);\n        });\n        memory.set(SudokuBox.create(x, y), map1);\n      }\n    }\n    return memory;\n  }\n\n  finderLogic(cantBes: Array<CantBeFoundEvent>): CantBeFoundEvent[] {\n    const results: CantBeFoundEvent[] = [];\n    for (let info of cantBes) {\n      let position = info.getPosition();\n      let nTNumber = info.getNumber();\n      let box: SudokuBox = SudokuBox.createByPosition(position);\n\n      const notHeres = this.memory.get(box)?.get(nTNumber);\n      if (notHeres && !notHeres.find((it) => samePosition(position, it))) {\n        notHeres.push(position);\n        if (notHeres.length >= 6 && notHeres.length <= 7) {\n          const possiblePositions: SudokuPosition[] = getAllPossiblePositions(\n            notHeres,\n            box,\n          );\n          const xCoordinatesOfPossiblePositions: SudokuXCoordinate[] =\n            getXCoordinatesOf(possiblePositions);\n          if (xCoordinatesOfPossiblePositions.length === 1) {\n            // TADA gefunden\n            const newCantBeFoundEvent: CantBeFoundEvent[] =\n              generateCantBeFoundEventFor(\n                xCoordinatesOfPossiblePositions[0],\n                nTNumber,\n                box,\n              );\n            results.push(...newCantBeFoundEvent);\n          }\n        }\n      }\n    }\n    return results;\n  }\n}\n\nfunction generateCantBeFoundEventFor(\n  xCoordinatesOfPossiblePositions: SudokuXCoordinate,\n  nTNumber: SudokuNumber,\n  box: SudokuBox,\n): CantBeFoundEvent[] {\n  const allYCoords: SudokuYCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n  return allYCoords\n    .map((yCoordinate) =>\n      SudokuPosition.of(xCoordinatesOfPossiblePositions, yCoordinate),\n    )\n    .filter((pos) => box.allSudokuPositionInThisBox().indexOf(pos) < 0)\n    .map(\n      (pos) =>\n        new CantBeFoundEvent(\n          pos,\n          nTNumber,\n          PairBasedExcluderInHorizontalLine.name,\n        ),\n    );\n}\n","import SudokuPosition from \"./sudoku/SudokuPosition\";\nimport RuleOrchestration from \"./sudoku/RuleOrchestration\";\nimport NumberFoundEvent from \"./sudoku/NumberFoundEvent\";\n\nlet ruleOrchestration = new RuleOrchestration();\n\n// eslint-disable-next-line no-restricted-globals\naddEventListener(\"message\", ({ data }) => {\n  console.log(\"worker got message\", data);\n\n  let sudokuEvent = new NumberFoundEvent(\n    SudokuPosition.of(data.field[0], data.field[1]),\n    data.value,\n    \"USER\"\n  );\n  ruleOrchestration.handleGivenNumber(sudokuEvent, postMessage);\n});\n","import BoxCantBeRule from \"../finder/numberFound2cantBe/BoxCantBeRule\";\nimport HorizontalCantBeRule from \"../finder/numberFound2cantBe/HorizontalCantBeRule\";\nimport VerticalCantBeRule from \"../finder/numberFound2cantBe/VerticalCantBeRule\";\nimport OnePositionCantBeRule from \"../finder/numberFound2cantBe/OnePositionCantBeRule\";\nimport OnlyOnePlaceHorizontalLine from \"../finder/cantBe2NumberFound/OnlyOnePlaceHorizontalLine\";\nimport OnlyOnePlaceVerticalLine from \"../finder/cantBe2NumberFound/OnlyOnePlaceVerticalLine\";\nimport OnlyOnePlaceBox from \"../finder/cantBe2NumberFound/OnlyOnePlaceBox\";\nimport OnePositionFinder from \"../finder/cantBe2NumberFound/OnePositionFinder\";\nimport EventFilter from \"./EventFilter\";\nimport CantBeFoundEvent from \"./CantBeFoundEvent\";\nimport NumberFound2CantBe from \"../finder/numberFound2cantBe/NumberFound2CantBe\";\nimport NumberFoundEvent from \"./NumberFoundEvent\";\nimport CantBe2NumberFound from \"../finder/cantBe2NumberFound/CantBe2NumberFound\";\nimport CantBe2CantBe from \"../finder/cantBe2cantBe/CantBe2CantBe\";\nimport PairBasedExcluderInVerticalLine from \"../finder/cantBe2cantBe/PairBasedExcluderInVerticalLine\";\nimport PairBasedExcluderInHorizontalLine from \"../finder/cantBe2cantBe/PairBasedExcluderInHorizontalLine\";\n\nexport default class RuleOrchestration {\n  private numberFound2cantBeRules: NumberFound2CantBe[];\n  private cantBe2NumberFound: CantBe2NumberFound[];\n  private cantBe2CantBe: CantBe2CantBe[];\n  private eventFilter: EventFilter;\n\n  constructor() {\n    this.numberFound2cantBeRules = [\n      new BoxCantBeRule(),\n      new HorizontalCantBeRule(),\n      new VerticalCantBeRule(),\n      new OnePositionCantBeRule(),\n    ];\n\n    this.cantBe2NumberFound = [\n      new OnlyOnePlaceHorizontalLine(),\n      new OnlyOnePlaceVerticalLine(),\n      new OnlyOnePlaceBox(),\n      new OnePositionFinder(),\n    ];\n\n    this.cantBe2CantBe = [\n      new PairBasedExcluderInVerticalLine(),\n      new PairBasedExcluderInHorizontalLine(),\n    ];\n\n    this.eventFilter = new EventFilter();\n  }\n\n  handleGivenNumber(\n    numberFoundEvent: NumberFoundEvent,\n    postMessage: (e: CantBeFoundEvent | NumberFoundEvent) => void,\n  ) {\n    let foundNumbers = this.eventFilter.removeAlreadySeen([numberFoundEvent]);\n    do {\n      let cantBeRulesResults: CantBeFoundEvent[] = [];\n      for (const rule of this.numberFound2cantBeRules) {\n        for (const foundNumber of foundNumbers) {\n          cantBeRulesResults = cantBeRulesResults.concat(\n            rule.finderLogic(foundNumber),\n          );\n        }\n      }\n\n      let cantBe2CantBeRulesResults: CantBeFoundEvent[] = [];\n      do {\n        cantBe2CantBeRulesResults = [];\n        for (const rule of this.cantBe2CantBe) {\n          for (const cantBe of cantBeRulesResults) {\n            cantBe2CantBeRulesResults = cantBe2CantBeRulesResults.concat(\n              rule.finderLogic(cantBeRulesResults),\n            );\n          }\n        }\n        cantBeRulesResults = cantBeRulesResults.concat(\n          cantBe2CantBeRulesResults,\n        );\n      } while (cantBe2CantBeRulesResults.length > 0);\n\n      cantBeRulesResults.forEach((it) => {\n        postMessage(it);\n      });\n\n      foundNumbers = [];\n      for (const rule of this.cantBe2NumberFound) {\n        foundNumbers = foundNumbers.concat(\n          rule.finderLogic(cantBeRulesResults),\n        );\n      }\n      foundNumbers = this.eventFilter.removeAlreadySeen(foundNumbers);\n      foundNumbers.forEach((foundNumbers) => {\n        postMessage(foundNumbers);\n      });\n    } while (foundNumbers.length > 0);\n  }\n}\n"],"names":["SudokuPosition","createAll","allYCoordinates","all","forEach","x","y","of","xCoordinate","yCoordinate","allInstances","constructor","this","getXCoordinate","getYCoordinate","toString","valueOf","SudokuBox","Error","getX","getY","getAll","allBoxCoordinates","createByPosition","postion","boxXCoordinate","boxCoordinateFor","boxYCoordinate","coordinate","sudokuCoordinateFor","create","allSudokuPositionInThisBox","result","yC","xC","position","push","SudokuEventType","CantBeFoundEvent","number","from","type","CANT_BE","getNumber","getPosition","getFrom","BoxCantBeRule","ruleName","finderLogic","numberFoundEvent","box","HorizontalCantBeRule","name","xk","yk","VerticalCantBeRule","OnePositionCantBeRule","i","NumberFoundEvent","NUMBER_FOUND","OnlyOnePlaceHorizontalLine","memory","initMemory","Map","numbers","map1","set","cantBes","cantBe","_this$memory$get","canBeForNumberInLine","get","find","it","length","onlyPossiblePosition","yCoordinates","OnlyOnePlaceVerticalLine","xCoordinates","samePosition","one","two","OnlyOnePlaceBox","init","results","info","nTNumber","notHeres","newPos","OnePositionFinder","notThisNumber","createBoolean3dArray","event","anzFalse","lastFalsePosition","array3d","j","k","EventFilter","numberFound","removeAlreadySeen","toFilter","filtered","getAllPossiblePositions","filter","pos","indexOf","getYCoordinatesOf","possiblePositions","distinct","map","getXCoordinatesOf","list","e","self","PairBasedExcluderInVerticalLine","yCoordinatesOfPossiblePositions","newCantBeFoundEvent","generateCantBeFoundEventFor","PairBasedExcluderInHorizontalLine","xCoordinatesOfPossiblePositions","ruleOrchestration","numberFound2cantBeRules","cantBe2NumberFound","cantBe2CantBe","eventFilter","handleGivenNumber","postMessage","foundNumbers","cantBeRulesResults","rule","foundNumber","concat","cantBe2CantBeRulesResults","addEventListener","data","console","log","sudokuEvent","field","value"],"sourceRoot":""}