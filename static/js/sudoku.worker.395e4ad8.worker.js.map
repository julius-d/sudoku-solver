{"version":3,"file":"static/js/sudoku.worker.395e4ad8.worker.js","mappings":"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","sources":["sudoku/SudokuPosition.tsx","sudoku/SudokuBox.tsx","sudoku/SudokuEventType.tsx","sudoku/CantBeFoundEvent.tsx","finder/numberFound2cantBe/BoxCantBeRule.tsx","finder/numberFound2cantBe/HorizontalCantBeRule.tsx","finder/numberFound2cantBe/VerticalCantBeRule.tsx","finder/numberFound2cantBe/OnePositionCantBeRule.tsx","sudoku/NumberFoundEvent.tsx","finder/cantBe2NumberFound/OnlyOnePlaceHorizontalLine.tsx","finder/cantBe2NumberFound/OnlyOnePlaceVerticalLine.tsx","finder/cantBe2NumberFound/OnlyOnePlaceBox.tsx","finder/cantBe2NumberFound/OnePositionFinder.tsx","sudoku/EventFilter.tsx","finder/cantBe2cantBe/Utils.ts","finder/cantBe2cantBe/PairBasedExcluderInVerticalLine.ts","finder/cantBe2cantBe/PairBasedExcluderInHorizontalLine.ts","sudoku.worker.js","sudoku/RuleOrchestration.tsx"],"sourcesContent":["import SudokuXCoordinate from \"./SudokuXCoordinate\";\nimport SudokuYCoordinate from \"./SudokuYCoordinate\";\n\n\nexport default class SudokuPosition {\n  readonly xCoordinate: SudokuXCoordinate;\n  readonly yCoordinate: SudokuYCoordinate;\n\n  private static allInstances: SudokuPosition[][] = SudokuPosition.createAll();\n\n  private static createAll() {\n    const allXCoordinates: SudokuXCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n    const allYCoordinates: SudokuYCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n    const all: SudokuPosition[][] = [[], [], [], [], [], [], [], [], []];\n    allXCoordinates.forEach(x => {\n      allYCoordinates.forEach(y => {\n        all[x][y] = new SudokuPosition(x, y);\n      });\n    });\n    return all;\n  }\n\n  public static of(xCoordinate: SudokuXCoordinate, yCoordinate: SudokuYCoordinate): SudokuPosition {\n    return SudokuPosition.allInstances[xCoordinate][yCoordinate];\n  }\n\n  private constructor(xCoordinate: SudokuXCoordinate, yCoordinate: SudokuYCoordinate) {\n    this.xCoordinate = xCoordinate;\n    this.yCoordinate = yCoordinate;\n  }\n\n  getXCoordinate() {\n    return this.xCoordinate;\n  }\n\n  getYCoordinate() {\n    return this.yCoordinate;\n  }\n\n  toString() {\n    return \"Pos: [\" + this.xCoordinate + \",\" + this.yCoordinate + \"]\";\n  }\n\n  valueOf() {\n    return \"[\" + this.xCoordinate + \"][\" + this.yCoordinate + \"]\";\n  }\n}\n","import SudokuPosition from \"./SudokuPosition\";\nimport SudokuYCoordinate from \"./SudokuYCoordinate\";\nimport SudokuXCoordinate from \"./SudokuXCoordinate\";\n\ntype BoxCoordinate = 0 | 1 | 2;\n\nexport default class SudokuBox {\n  private readonly x: BoxCoordinate;\n  private readonly y: BoxCoordinate;\n\n  private static allInstances: SudokuBox[][] = SudokuBox.createAll();\n\n  private constructor(x: BoxCoordinate, y: BoxCoordinate) {\n    if (x < 0 || y < 0 || x > 2 || y > 2) {\n      throw new Error(\"illegal argument x:\" + x + \" y: \" + y);\n    }\n    this.x = x;\n    this.y = y;\n  }\n\n  getX() {\n    return this.x;\n  }\n\n  getY() {\n    return this.y;\n  }\n\n  getAll() {\n    return SudokuBox.allInstances;\n  }\n\n  private static createAll() {\n    const allBoxCoordinates: BoxCoordinate[] = [0, 1, 2];\n    const all: SudokuBox[][] = [[], [], []];\n    allBoxCoordinates.forEach(x => {\n      allBoxCoordinates.forEach(y => {\n        all[x][y] = new SudokuBox(x, y);\n      });\n    });\n    return all;\n  }\n\n  static createByPosition(postion: SudokuPosition) {\n    const x = postion.getXCoordinate();\n    const y = postion.getYCoordinate();\n    const boxXCoordinate = this.boxCoordinateFor(x);\n    const boxYCoordinate = this.boxCoordinateFor(y);\n    return this.allInstances[boxXCoordinate][boxYCoordinate];\n  }\n\n  private static boxCoordinateFor(\n    coordinate: SudokuXCoordinate | SudokuYCoordinate\n  ) {\n    if (coordinate === 0 || coordinate === 1 || coordinate === 2) {\n      return 0;\n    } else if (coordinate === 3 || coordinate === 4 || coordinate === 5) {\n      return 1;\n    } else {\n      return 2;\n    }\n  }\n\n  private static sudokuCoordinateFor(\n    coordinate: BoxCoordinate\n  ): Array<SudokuXCoordinate | SudokuYCoordinate> {\n    if (coordinate === 0) {\n      return [0, 1, 2];\n    } else if (coordinate === 1) {\n      return [3, 4, 5];\n    } else {\n      return [6, 7, 8];\n    }\n  }\n\n  static create(x: number, y: number) {\n    return this.allInstances[x][y];\n  }\n\n  allSudokuPositionInThisBox() {\n    let result: SudokuPosition[] = [];\n    SudokuBox.sudokuCoordinateFor(this.y).forEach(yC => {\n      SudokuBox.sudokuCoordinateFor(this.x).forEach(xC => {\n        const position = SudokuPosition.of(xC, yC);\n        result.push(position);\n      });\n    });\n    return result;\n  }\n\n  toString() {\n    return \"Box: [\" + this.x + \",\" + this.y + \"]\";\n  }\n}\n","enum SudokuEventType {\n  CANT_BE,\n  NUMBER_FOUND\n}\nexport default SudokuEventType;\n","import SudokuPosition from \"./SudokuPosition\";\nimport SudokuEventType from \"./SudokuEventType\";\nimport SudokuNumber from \"./SudokuNumber\";\n\nexport default class CantBeFoundEvent {\n  readonly type: SudokuEventType = SudokuEventType.CANT_BE;\n  readonly position: SudokuPosition;\n  readonly number: SudokuNumber;\n  readonly from: string;\n\n  constructor(postion: SudokuPosition, number: SudokuNumber, from: string) {\n    this.position = postion;\n    this.number = number;\n    this.from = from;\n  }\n\n  getNumber() {\n    return this.number;\n  }\n\n  getPosition() {\n    return this.position;\n  }\n\n  getFrom() {\n    return this.from;\n  }\n}\n","import SudokuBox from \"../../sudoku/SudokuBox\";\nimport CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport NumberFound2CantBe from \"./NumberFound2CantBe\";\n\nexport default class BoxCantBeRule implements NumberFound2CantBe {\n  private readonly ruleName = \"BoxCantBeRule\";\n\n  finderLogic(numberFoundEvent: NumberFoundEvent) {\n    const result = [];\n    const box = SudokuBox.createByPosition(numberFoundEvent.getPosition());\n\n    for (let position of box.allSudokuPositionInThisBox()) {\n      if (\n        position.getYCoordinate() !==\n          numberFoundEvent.getPosition().getYCoordinate() ||\n        position.getXCoordinate() !==\n          numberFoundEvent.getPosition().getXCoordinate()\n      ) {\n        result.push(\n          new CantBeFoundEvent(\n            position,\n            numberFoundEvent.getNumber(),\n            this.ruleName\n          )\n        );\n      }\n    }\n\n    return result;\n  }\n}\n","import CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport NumberFound2CantBe from \"./NumberFound2CantBe\";\nimport SudokuYCoordinate from \"../../sudoku/SudokuYCoordinate\";\n\nexport default class HorizontalCantBeRule implements NumberFound2CantBe {\n  private readonly name = \"HorizontalCantBeRule\";\n\n  finderLogic(numberFoundEvent: NumberFoundEvent) {\n    const result: CantBeFoundEvent[] = [];\n    const yCoordinates: SudokuYCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n\n    let xk = numberFoundEvent.getPosition().getXCoordinate();\n    yCoordinates.forEach(yk => {\n      if (yk !== numberFoundEvent.getPosition().getYCoordinate()) {\n        result.push(\n          new CantBeFoundEvent(\n            SudokuPosition.of(xk, yk),\n            numberFoundEvent.getNumber(),\n            this.name\n          )\n        );\n      }\n    });\n\n    return result;\n  }\n}\n","import CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport NumberFound2CantBe from \"./NumberFound2CantBe\";\nimport SudokuXCoordinate from \"../../sudoku/SudokuXCoordinate\";\n\nexport default class VerticalCantBeRule implements NumberFound2CantBe {\n  private readonly name = \"VerticalCantBeRule\";\n\n  finderLogic(numberFoundEvent: NumberFoundEvent) {\n    const result: CantBeFoundEvent[] = [];\n    const xCoordinates: SudokuXCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n\n    let yk = numberFoundEvent.getPosition().getYCoordinate();\n    xCoordinates.forEach(xk => {\n      if (xk !== numberFoundEvent.getPosition().getXCoordinate()) {\n        result.push(\n          new CantBeFoundEvent(\n            SudokuPosition.of(xk, yk),\n            numberFoundEvent.getNumber(),\n            this.name\n          )\n        );\n      }\n    });\n    return result;\n  }\n}\n","import CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport NumberFound2CantBe from \"./NumberFound2CantBe\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\n\nexport default class OnePositionCantBeRule implements NumberFound2CantBe {\n  private readonly name = \"OnePositionCantBeRule\";\n\n  finderLogic(numberFoundEvent: NumberFoundEvent) {\n    const result: CantBeFoundEvent[] = [];\n    const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    numbers.forEach(i => {\n      if (i !== numberFoundEvent.getNumber()) {\n        result.push(\n          new CantBeFoundEvent(numberFoundEvent.getPosition(), i, this.name)\n        );\n      }\n    });\n    return result;\n  }\n}\n","import SudokuPosition from \"./SudokuPosition\";\nimport SudokuEventType from \"./SudokuEventType\";\nimport SudokuNumber from \"./SudokuNumber\";\n\nexport default class NumberFoundEvent {\n  readonly type = SudokuEventType.NUMBER_FOUND;\n  readonly position: SudokuPosition;\n  readonly number: SudokuNumber;\n  readonly from: string;\n\n  constructor(position: SudokuPosition, number: SudokuNumber, from: string) {\n    this.position = position;\n    this.number = number;\n    this.from = from;\n  }\n\n  getNumber() {\n    return this.number;\n  }\n\n  getPosition() {\n    return this.position;\n  }\n\n  getFrom() {\n    return this.from;\n  }\n}\n","import SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport CantBe2NumberFound from \"./CantBe2NumberFound\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\nimport SudokuYCoordinate from \"../../sudoku/SudokuYCoordinate\";\n\nexport default class OnlyOnePlaceHorizontalLine implements CantBe2NumberFound {\n  /**\n   * Es wird für jede Zeile(0-8) für jede Zahl(1-9) gespeichert, wo sie nicht hin darf.\n   */\n  private readonly memory: Map<\n    number,\n    Map<SudokuNumber, Array<SudokuPosition>>\n  >;\n  private readonly name = \"OnlyOnePlaceHorizontalLine\";\n\n  constructor() {\n    this.memory = OnlyOnePlaceHorizontalLine.initMemory();\n  }\n\n  private static initMemory() {\n    const memory = new Map<number, Map<SudokuNumber, Array<SudokuPosition>>>();\n    const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\n    for (let x: number = 0; x < 9; x++) {\n      let map1 = new Map<SudokuNumber, Array<SudokuPosition>>();\n      numbers.forEach(i => {\n        map1.set(i, []);\n      });\n      memory.set(x, map1);\n    }\n    return memory;\n  }\n\n  finderLogic(cantBes: Array<CantBeFoundEvent>): Array<NumberFoundEvent> {\n    const result: Array<NumberFoundEvent> = [];\n    cantBes.forEach(cantBe => {\n      const canBeForNumberInLine =\n        this.memory\n          .get(cantBe.getPosition().getXCoordinate())\n          ?.get(cantBe.getNumber()) || []; // TODO handle undefine\n      if (\n        !canBeForNumberInLine.find(\n          it =>\n            it.getXCoordinate() === cantBe.getPosition().getXCoordinate() &&\n            it.getYCoordinate() === cantBe.getPosition().getYCoordinate()\n        )\n      ) {\n        canBeForNumberInLine.push(cantBe.getPosition());\n        if (canBeForNumberInLine.length === 8) {\n          result.push(\n            new NumberFoundEvent(\n              OnlyOnePlaceHorizontalLine.onlyPossiblePosition(\n                canBeForNumberInLine\n              ),\n              cantBe.getNumber(),\n              this.name\n            )\n          );\n        }\n      }\n    });\n    return result;\n  }\n\n  private static onlyPossiblePosition(\n    canBeForNumberInLine: SudokuPosition[]\n  ): SudokuPosition {\n    const yCoordinates: SudokuYCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n    for (let i = 0; i < yCoordinates.length; i++) {\n      let yCoordinate = yCoordinates[i];\n      if (\n        !canBeForNumberInLine.find(it => it.getYCoordinate() === yCoordinate)\n      ) {\n        return SudokuPosition.of(\n          canBeForNumberInLine[0].getXCoordinate(),\n          yCoordinate\n        );\n      }\n    }\n    throw new Error(\"should not happen\");\n  }\n}\n","import SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport CantBe2NumberFound from \"./CantBe2NumberFound\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\nimport SudokuXCoordinate from \"../../sudoku/SudokuXCoordinate\";\nimport SudokuYCoordinate from \"../../sudoku/SudokuYCoordinate\";\n\nexport default class OnlyOnePlaceVerticalLine implements CantBe2NumberFound {\n  /**\n   * Es wird für jede Reihe(0-8) für jede Zahl(1-9) gespeichert, wo sie nicht hin darf.\n   */\n  private readonly memory: Map<\n    SudokuYCoordinate,\n    Map<SudokuNumber, Array<SudokuPosition>>\n  >;\n  private readonly name = \"OnlyOnePlaceVerticalLine\";\n\n  constructor() {\n    this.memory = OnlyOnePlaceVerticalLine.initMemory();\n  }\n\n  static initMemory() {\n    const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    const sudokuYCoordinates: SudokuYCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n\n    const memory = new Map<\n      SudokuYCoordinate,\n      Map<SudokuNumber, Array<SudokuPosition>>\n    >();\n    sudokuYCoordinates.forEach(x => {\n      let map1 = new Map<SudokuNumber, Array<SudokuPosition>>();\n      numbers.forEach(i => {\n        map1.set(i, []);\n      });\n      memory.set(x, map1);\n    });\n    return memory;\n  }\n\n  finderLogic(cantBes: Array<CantBeFoundEvent>): Array<NumberFoundEvent> {\n    const result: Array<NumberFoundEvent> = [];\n    cantBes.forEach(cantBe => {\n      const canBeForNumberInLine =\n        this.memory\n          .get(cantBe.getPosition().getYCoordinate())\n          ?.get(cantBe.getNumber()) || []; // TODO handle undefined\n      if (\n        !canBeForNumberInLine.find(\n          it =>\n            it.getXCoordinate() === cantBe.getPosition().getXCoordinate() &&\n            it.getYCoordinate() === cantBe.getPosition().getYCoordinate()\n        )\n      ) {\n        canBeForNumberInLine.push(cantBe.getPosition());\n        if (canBeForNumberInLine.length === 8) {\n          result.push(\n            new NumberFoundEvent(\n              OnlyOnePlaceVerticalLine.onlyPossiblePosition(\n                canBeForNumberInLine\n              ),\n              cantBe.getNumber(),\n              this.name\n            )\n          );\n        }\n      }\n    });\n    return result;\n  }\n\n  private static onlyPossiblePosition(\n    canBeForNumberInLine: SudokuPosition[]\n  ): SudokuPosition {\n    const xCoordinates: SudokuXCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n    for (let i = 0; i < xCoordinates.length; i++) {\n      let xCoordinate = xCoordinates[i];\n      if (\n        !canBeForNumberInLine.find(it => it.getXCoordinate() === xCoordinate)\n      ) {\n        return SudokuPosition.of(\n          xCoordinate,\n          canBeForNumberInLine[0].getYCoordinate()\n        );\n      }\n    }\n    throw new Error(\"should not happen\");\n  }\n}\n","import SudokuBox from \"../../sudoku/SudokuBox\";\nimport SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport CantBe2NumberFound from \"./CantBe2NumberFound\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\n\nfunction samePosition(one: SudokuPosition, two: SudokuPosition) {\n  return (\n    one.getXCoordinate() === two.getXCoordinate() &&\n    one.getYCoordinate() === two.getYCoordinate()\n  );\n}\n\nexport default class OnlyOnePlaceBox implements CantBe2NumberFound {\n  /**\n   * Es wird für jede Box für jede Zahl(1-9) gespeichert, wo sie nicht hin darf.\n   */\n  private readonly memory: Map<\n    SudokuBox,\n    Map<SudokuNumber, Array<SudokuPosition>>\n  > = OnlyOnePlaceBox.init();\n  private readonly name = \"OnlyOnePlaceBox\";\n\n  private static init() {\n    const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    const memory = new Map<\n      SudokuBox,\n      Map<SudokuNumber, Array<SudokuPosition>>\n    >();\n    for (let x = 0; x < 3; x++) {\n      for (let y = 0; y < 3; y++) {\n        let map1 = new Map<SudokuNumber, Array<SudokuPosition>>();\n        numbers.forEach(i => {\n          map1.set(i, []);\n        });\n        memory.set(SudokuBox.create(x, y), map1);\n      }\n    }\n    return memory;\n  }\n\n  finderLogic(cantBes: Array<CantBeFoundEvent>) {\n    const results: NumberFoundEvent[] = [];\n    for (let info of cantBes) {\n      let position = info.getPosition();\n      let nTNumber = info.getNumber();\n      let box: SudokuBox = SudokuBox.createByPosition(position);\n\n      const notHeres = this.memory.get(box)?.get(nTNumber);\n      if (notHeres && !notHeres.find(it => samePosition(position, it))) {\n        notHeres.push(position);\n        if (notHeres.length === 8) {\n          box.allSudokuPositionInThisBox().forEach(newPos => {\n            if (!notHeres.find(it => samePosition(newPos, it))) {\n              results.push(new NumberFoundEvent(newPos, nTNumber, this.name)); //FIXME\n            }\n          });\n        }\n      }\n    }\n    return results;\n  }\n}\n","import CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport CantBe2NumberFound from \"./CantBe2NumberFound\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\n\nexport default class OnePositionFinder implements CantBe2NumberFound {\n  private readonly notThisNumber: boolean[][][] = OnePositionFinder.createBoolean3dArray();\n  private readonly name = \"OnePositionFinder\";\n\n  finderLogic(cantBes: CantBeFoundEvent[]) {\n    const results: NumberFoundEvent[] = [];\n    for (let event of cantBes) {\n      const position = event.getPosition();\n      const nTNumber = event.getNumber();\n      this.notThisNumber[position.getXCoordinate()][position.getYCoordinate()][\n        nTNumber\n      ] = true;\n\n      let anzFalse = 0;\n      let lastFalsePosition: SudokuNumber | null = null;\n      const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\n      numbers.forEach(i => {\n        if (\n          !this.notThisNumber[position.getXCoordinate()][\n            position.getYCoordinate()\n          ][i]\n        ) {\n          anzFalse++;\n          lastFalsePosition = i;\n        }\n      });\n      if (anzFalse === 1 && lastFalsePosition !== null) {\n        results.push(\n          new NumberFoundEvent(position, lastFalsePosition, this.name)\n        );\n      }\n    }\n    return results;\n  }\n\n  private static createBoolean3dArray() {\n    const array3d: boolean[][][] = [];\n\n    for (let i = 0; i < 9; i++) {\n      array3d[i] = [];\n      for (let j = 0; j < 9; j++) {\n        array3d[i][j] = [];\n        for (let k = 0; k < 9; k++) {\n          array3d[i][j][k] = false;\n        }\n      }\n    }\n\n    return array3d;\n  }\n}\n","import SudokuEventType from \"./SudokuEventType\";\nimport NumberFoundEvent from \"./NumberFoundEvent\";\n\nexport default class EventFilter {\n  private numberFound: number[][] = [[], [], [], [], [], [], [], [], []];\n\n  removeAlreadySeen(toFilter: NumberFoundEvent[]) {\n    const filtered = [];\n\n    for (const numberFoundEvent of toFilter) {\n      if (numberFoundEvent.type === SudokuEventType.NUMBER_FOUND) {\n        if (\n          !this.numberFound[numberFoundEvent.getPosition().getXCoordinate()][\n            numberFoundEvent.getPosition().getYCoordinate()\n          ]\n        ) {\n          this.numberFound[numberFoundEvent.getPosition().getXCoordinate()][\n            numberFoundEvent.getPosition().getYCoordinate()\n          ] = numberFoundEvent.getNumber();\n          filtered.push(numberFoundEvent);\n        }\n        // TODO validate number in case of alerdy seen\n      } else {\n        // filter CANT BES\n        filtered.push(numberFoundEvent);\n      }\n    }\n    return filtered;\n  }\n}\n","import SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport SudokuBox from \"../../sudoku/SudokuBox\";\nimport SudokuYCoordinate from \"../../sudoku/SudokuYCoordinate\";\nimport SudokuXCoordinate from \"../../sudoku/SudokuXCoordinate\";\n\n\nexport function getAllPossiblePositions(notHeres: SudokuPosition[], box: SudokuBox): SudokuPosition[] {\n  return box.allSudokuPositionInThisBox().filter(pos => notHeres.indexOf(pos) < 0);\n}\n\nexport function getYCoordinatesOf(possiblePositions: SudokuPosition[]): SudokuYCoordinate[] {\n  return distinct(possiblePositions.map(pos => pos.getYCoordinate()));\n}\n\nexport function getXCoordinatesOf(possiblePositions: SudokuPosition[]): SudokuXCoordinate[] {\n  return distinct(possiblePositions.map(pos => pos.getXCoordinate()));\n}\n\nfunction distinct<T>(list: Array<T>): Array<T> {\n  return list.filter((e, i, self) => i === self.indexOf(e));\n}\n","import SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\nimport SudokuXCoordinate from \"../../sudoku/SudokuXCoordinate\";\nimport SudokuYCoordinate from \"../../sudoku/SudokuYCoordinate\";\nimport SudokuBox from \"../../sudoku/SudokuBox\";\nimport CantBe2CantBe from \"./CantBe2CantBe\";\nimport {getAllPossiblePositions, getYCoordinatesOf} from \"./Utils\";\n\nfunction samePosition(one: SudokuPosition, two: SudokuPosition) {\n  return (\n    one.getXCoordinate() === two.getXCoordinate() &&\n    one.getYCoordinate() === two.getYCoordinate()\n  );\n}\n\nexport default class PairBasedExcluderInVerticalLine implements CantBe2CantBe {\n  /**\n   * Es wird für jede Box für jede Zahl(1-9) gespeichert, wo sie nicht hin darf.\n   */\n  private readonly memory: Map<\n    SudokuBox,\n    Map<SudokuNumber, Array<SudokuPosition>>\n  > = PairBasedExcluderInVerticalLine.init();\n  private readonly name = \"PairBasedExcluderInVerticalLine\";\n\n  private static init() {\n    const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    const memory = new Map<\n      SudokuBox,\n      Map<SudokuNumber, Array<SudokuPosition>>\n    >();\n    for (let x = 0; x < 3; x++) {\n      for (let y = 0; y < 3; y++) {\n        let map1 = new Map<SudokuNumber, Array<SudokuPosition>>();\n        numbers.forEach(i => {\n          map1.set(i, []);\n        });\n        memory.set(SudokuBox.create(x, y), map1);\n      }\n    }\n    return memory;\n  }\n\n  finderLogic(cantBes: Array<CantBeFoundEvent>): CantBeFoundEvent[] {\n    const results: CantBeFoundEvent[] = [];\n    for (let info of cantBes) {\n      let position = info.getPosition();\n      let nTNumber = info.getNumber();\n      let box: SudokuBox = SudokuBox.createByPosition(position);\n\n      const notHeres = this.memory.get(box)?.get(nTNumber);\n      if (notHeres && !notHeres.find(it => samePosition(position, it))) {\n        notHeres.push(position);\n        if (notHeres.length >= 6 && notHeres.length <= 7) {\n\n          const possiblePositions: SudokuPosition[] = getAllPossiblePositions(notHeres, box);\n          const yCoordinatesOfPossiblePositions: SudokuYCoordinate[] = getYCoordinatesOf(possiblePositions);\n          if (yCoordinatesOfPossiblePositions.length === 1) {\n            // TADA gefunden\n            const newCantBeFoundEvent: CantBeFoundEvent[] = generateCantBeFoundEventFor(yCoordinatesOfPossiblePositions[0], nTNumber, box);\n            results.push(...newCantBeFoundEvent);\n          }\n        }\n      }\n    }\n    return results;\n  }\n}\n\n\nfunction generateCantBeFoundEventFor(yCoordinatesOfPossiblePositions: SudokuYCoordinate, nTNumber: SudokuNumber, box: SudokuBox): CantBeFoundEvent[] {\n  const allXCoords: SudokuXCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n  return allXCoords\n    .map(xCoordinate => SudokuPosition.of(xCoordinate, yCoordinatesOfPossiblePositions))\n    .filter(pos => box.allSudokuPositionInThisBox().indexOf(pos) < 0)\n    .map(pos => new CantBeFoundEvent(pos, nTNumber, PairBasedExcluderInVerticalLine.name));\n}\n","import SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\nimport SudokuXCoordinate from \"../../sudoku/SudokuXCoordinate\";\nimport SudokuYCoordinate from \"../../sudoku/SudokuYCoordinate\";\nimport SudokuBox from \"../../sudoku/SudokuBox\";\nimport CantBe2CantBe from \"./CantBe2CantBe\";\nimport {getAllPossiblePositions, getXCoordinatesOf} from \"./Utils\";\n\nfunction samePosition(one: SudokuPosition, two: SudokuPosition) {\n  return (\n    one.getXCoordinate() === two.getXCoordinate() &&\n    one.getYCoordinate() === two.getYCoordinate()\n  );\n}\n\nexport default class PairBasedExcluderInHorizontalLine implements CantBe2CantBe {\n  /**\n   * Es wird für jede Box für jede Zahl(1-9) gespeichert, wo sie nicht hin darf.\n   */\n  private readonly memory: Map<\n    SudokuBox,\n    Map<SudokuNumber, Array<SudokuPosition>>\n  > = PairBasedExcluderInHorizontalLine.init();\n  private readonly name = \"PairBasedExcluderInHorizontalLine\";\n\n  private static init() {\n    const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    const memory = new Map<\n      SudokuBox,\n      Map<SudokuNumber, Array<SudokuPosition>>\n    >();\n    for (let x = 0; x < 3; x++) {\n      for (let y = 0; y < 3; y++) {\n        let map1 = new Map<SudokuNumber, Array<SudokuPosition>>();\n        numbers.forEach(i => {\n          map1.set(i, []);\n        });\n        memory.set(SudokuBox.create(x, y), map1);\n      }\n    }\n    return memory;\n  }\n\n  finderLogic(cantBes: Array<CantBeFoundEvent>): CantBeFoundEvent[] {\n    const results: CantBeFoundEvent[] = [];\n    for (let info of cantBes) {\n      let position = info.getPosition();\n      let nTNumber = info.getNumber();\n      let box: SudokuBox = SudokuBox.createByPosition(position);\n\n      const notHeres = this.memory.get(box)?.get(nTNumber);\n      if (notHeres && !notHeres.find(it => samePosition(position, it))) {\n        notHeres.push(position);\n        if (notHeres.length >= 6 && notHeres.length <= 7) {\n\n          const possiblePositions: SudokuPosition[] = getAllPossiblePositions(notHeres, box);\n          const xCoordinatesOfPossiblePositions: SudokuXCoordinate[] = getXCoordinatesOf(possiblePositions);\n          if (xCoordinatesOfPossiblePositions.length === 1) {\n            // TADA gefunden\n            const newCantBeFoundEvent: CantBeFoundEvent[] = generateCantBeFoundEventFor(xCoordinatesOfPossiblePositions[0], nTNumber, box);\n            results.push(...newCantBeFoundEvent);\n          }\n        }\n      }\n    }\n    return results;\n  }\n}\n\n\nfunction generateCantBeFoundEventFor(xCoordinatesOfPossiblePositions: SudokuXCoordinate, nTNumber: SudokuNumber, box: SudokuBox): CantBeFoundEvent[] {\n  const allYCoords: SudokuYCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n  return allYCoords\n    .map(yCoordinate => SudokuPosition.of(xCoordinatesOfPossiblePositions, yCoordinate))\n    .filter(pos => box.allSudokuPositionInThisBox().indexOf(pos) < 0)\n    .map(pos => new CantBeFoundEvent(pos, nTNumber, PairBasedExcluderInHorizontalLine.name));\n}\n","import SudokuPosition from \"./sudoku/SudokuPosition\";\nimport RuleOrchestration from \"./sudoku/RuleOrchestration\";\nimport NumberFoundEvent from \"./sudoku/NumberFoundEvent\";\n\nlet ruleOrchestration = new RuleOrchestration();\n\n// eslint-disable-next-line no-restricted-globals\naddEventListener(\"message\", ({ data }) => {\n  console.log(\"worker got message\", data);\n\n  let sudokuEvent = new NumberFoundEvent(\n    SudokuPosition.of(data.field[0], data.field[1]),\n    data.value,\n    \"USER\"\n  );\n  ruleOrchestration.handleGivenNumber(sudokuEvent, postMessage);\n});\n","import BoxCantBeRule from \"../finder/numberFound2cantBe/BoxCantBeRule\";\nimport HorizontalCantBeRule from \"../finder/numberFound2cantBe/HorizontalCantBeRule\";\nimport VerticalCantBeRule from \"../finder/numberFound2cantBe/VerticalCantBeRule\";\nimport OnePositionCantBeRule from \"../finder/numberFound2cantBe/OnePositionCantBeRule\";\nimport OnlyOnePlaceHorizontalLine from \"../finder/cantBe2NumberFound/OnlyOnePlaceHorizontalLine\";\nimport OnlyOnePlaceVerticalLine from \"../finder/cantBe2NumberFound/OnlyOnePlaceVerticalLine\";\nimport OnlyOnePlaceBox from \"../finder/cantBe2NumberFound/OnlyOnePlaceBox\";\nimport OnePositionFinder from \"../finder/cantBe2NumberFound/OnePositionFinder\";\nimport EventFilter from \"./EventFilter\";\nimport CantBeFoundEvent from \"./CantBeFoundEvent\";\nimport NumberFound2CantBe from \"../finder/numberFound2cantBe/NumberFound2CantBe\";\nimport NumberFoundEvent from \"./NumberFoundEvent\";\nimport CantBe2NumberFound from \"../finder/cantBe2NumberFound/CantBe2NumberFound\";\nimport CantBe2CantBe from \"../finder/cantBe2cantBe/CantBe2CantBe\";\nimport PairBasedExcluderInVerticalLine from \"../finder/cantBe2cantBe/PairBasedExcluderInVerticalLine\";\nimport PairBasedExcluderInHorizontalLine from \"../finder/cantBe2cantBe/PairBasedExcluderInHorizontalLine\";\n\n\nexport default class RuleOrchestration {\n\n  private numberFound2cantBeRules: NumberFound2CantBe[];\n  private cantBe2NumberFound: CantBe2NumberFound[];\n  private cantBe2CantBe: CantBe2CantBe[];\n  private eventFilter: EventFilter;\n\n  constructor() {\n    this.numberFound2cantBeRules = [\n      new BoxCantBeRule(),\n      new HorizontalCantBeRule(),\n      new VerticalCantBeRule(),\n      new OnePositionCantBeRule()\n    ];\n\n    this.cantBe2NumberFound = [\n      new OnlyOnePlaceHorizontalLine(),\n      new OnlyOnePlaceVerticalLine(),\n      new OnlyOnePlaceBox(),\n      new OnePositionFinder()\n    ];\n\n    this.cantBe2CantBe = [\n      new PairBasedExcluderInVerticalLine(),\n      new PairBasedExcluderInHorizontalLine(),\n    ]\n\n    this.eventFilter = new EventFilter();\n  }\n\n  handleGivenNumber(\n    numberFoundEvent: NumberFoundEvent,\n    postMessage: (e: CantBeFoundEvent | NumberFoundEvent) => void\n  ) {\n    let foundNumbers = this.eventFilter.removeAlreadySeen([numberFoundEvent]);\n    do {\n      let cantBeRulesResults: CantBeFoundEvent[] = [];\n      for (const rule of this.numberFound2cantBeRules) {\n        for (const foundNumber of foundNumbers) {\n          cantBeRulesResults = cantBeRulesResults.concat(\n            rule.finderLogic(foundNumber)\n          );\n        }\n      }\n\n      let cantBe2CantBeRulesResults: CantBeFoundEvent[] = [];\n      do {\n        cantBe2CantBeRulesResults = [];\n        for (const rule of this.cantBe2CantBe) {\n          for (const cantBe of cantBeRulesResults) {\n            cantBe2CantBeRulesResults = cantBe2CantBeRulesResults.concat(\n              rule.finderLogic(cantBeRulesResults)\n            );\n          }\n        }\n        cantBeRulesResults = cantBeRulesResults.concat(cantBe2CantBeRulesResults);\n      } while (cantBe2CantBeRulesResults.length > 0);\n\n      cantBeRulesResults.forEach(it => {\n        postMessage(it);\n      });\n\n      foundNumbers = [];\n      for (const rule of this.cantBe2NumberFound) {\n        foundNumbers = foundNumbers.concat(\n          rule.finderLogic(cantBeRulesResults)\n        );\n      }\n      foundNumbers = this.eventFilter.removeAlreadySeen(foundNumbers);\n      foundNumbers.forEach(foundNumbers => {\n        postMessage(foundNumbers);\n      });\n    } while (foundNumbers.length > 0);\n  }\n}\n"],"names":["SudokuPosition","createAll","allYCoordinates","all","forEach","x","y","of","xCoordinate","yCoordinate","allInstances","constructor","this","getXCoordinate","getYCoordinate","toString","valueOf","SudokuBox","Error","getX","getY","getAll","allBoxCoordinates","createByPosition","postion","boxXCoordinate","boxCoordinateFor","boxYCoordinate","coordinate","sudokuCoordinateFor","create","allSudokuPositionInThisBox","result","yC","xC","position","push","SudokuEventType","CantBeFoundEvent","number","from","type","CANT_BE","getNumber","getPosition","getFrom","BoxCantBeRule","ruleName","finderLogic","numberFoundEvent","box","HorizontalCantBeRule","name","xk","yk","VerticalCantBeRule","OnePositionCantBeRule","i","NumberFoundEvent","NUMBER_FOUND","OnlyOnePlaceHorizontalLine","memory","initMemory","Map","numbers","map1","set","cantBes","cantBe","_this$memory$get","canBeForNumberInLine","get","find","it","length","onlyPossiblePosition","yCoordinates","OnlyOnePlaceVerticalLine","xCoordinates","samePosition","one","two","OnlyOnePlaceBox","init","results","info","nTNumber","notHeres","newPos","OnePositionFinder","notThisNumber","createBoolean3dArray","event","anzFalse","lastFalsePosition","array3d","j","k","EventFilter","numberFound","removeAlreadySeen","toFilter","filtered","getAllPossiblePositions","filter","pos","indexOf","getYCoordinatesOf","possiblePositions","distinct","map","getXCoordinatesOf","list","e","self","PairBasedExcluderInVerticalLine","yCoordinatesOfPossiblePositions","newCantBeFoundEvent","generateCantBeFoundEventFor","PairBasedExcluderInHorizontalLine","xCoordinatesOfPossiblePositions","ruleOrchestration","numberFound2cantBeRules","cantBe2NumberFound","cantBe2CantBe","eventFilter","handleGivenNumber","postMessage","foundNumbers","cantBeRulesResults","rule","foundNumber","concat","cantBe2CantBeRulesResults","addEventListener","data","console","log","sudokuEvent","field","value"],"sourceRoot":""}