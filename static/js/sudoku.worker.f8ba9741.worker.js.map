{"version":3,"file":"static/js/sudoku.worker.f8ba9741.worker.js","mappings":"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","sources":["../node_modules/@babel/runtime/helpers/esm/classCallCheck.js","../node_modules/@babel/runtime/helpers/esm/createClass.js","sudoku/SudokuPosition.tsx","../node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","sudoku/SudokuBox.tsx","sudoku/SudokuEventType.tsx","sudoku/CantBeFoundEvent.tsx","finder/numberFound2cantBe/BoxCantBeRule.tsx","finder/numberFound2cantBe/HorizontalCantBeRule.tsx","finder/numberFound2cantBe/VerticalCantBeRule.tsx","finder/numberFound2cantBe/OnePositionCantBeRule.tsx","sudoku/NumberFoundEvent.tsx","finder/cantBe2NumberFound/OnlyOnePlaceHorizontalLine.tsx","finder/cantBe2NumberFound/OnlyOnePlaceVerticalLine.tsx","finder/cantBe2NumberFound/OnlyOnePlaceBox.tsx","finder/cantBe2NumberFound/OnePositionFinder.tsx","sudoku/EventFilter.tsx","sudoku/RuleOrchestration.tsx","sudoku.worker.js"],"sourcesContent":["export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","import SudokuXCoordinate from \"./SudokuXCoordinate\";\nimport SudokuYCoordinate from \"./SudokuYCoordinate\";\n\nexport default class SudokuPosition {\n  readonly xCoordinate: SudokuXCoordinate;\n  readonly yCoordinate: SudokuYCoordinate;\n\n  constructor(xCoordinate: SudokuXCoordinate, yCoordinate: SudokuYCoordinate) {\n    this.xCoordinate = xCoordinate;\n    this.yCoordinate = yCoordinate;\n  }\n\n  getXCoordinate() {\n    return this.xCoordinate;\n  }\n\n  getYCoordinate() {\n    return this.yCoordinate;\n  }\n\n  toString() {\n    return \"Pos: [\" + this.xCoordinate + \",\" + this.yCoordinate + \"]\";\n  }\n\n  valueOf() {\n    return \"[\" + this.xCoordinate + \"][\" + this.yCoordinate + \"]\";\n  }\n}\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      var F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var normalCompletion = true,\n    didErr = false,\n    err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","import SudokuPosition from \"./SudokuPosition\";\nimport SudokuYCoordinate from \"./SudokuYCoordinate\";\nimport SudokuXCoordinate from \"./SudokuXCoordinate\";\n\ntype BoxCoordinate = 0 | 1 | 2;\n\nexport default class SudokuBox {\n  private readonly x: BoxCoordinate;\n  private readonly y: BoxCoordinate;\n\n  private static allInstances: SudokuBox[][] = SudokuBox.createAll();\n\n  private constructor(x: BoxCoordinate, y: BoxCoordinate) {\n    if (x < 0 || y < 0 || x > 2 || y > 2) {\n      throw new Error(\"illegal argument x:\" + x + \" y: \" + y);\n    }\n    this.x = x;\n    this.y = y;\n  }\n\n  getX() {\n    return this.x;\n  }\n\n  getY() {\n    return this.y;\n  }\n\n  getAll() {\n    return SudokuBox.allInstances;\n  }\n\n  private static createAll() {\n    const allBoxCoordinates: BoxCoordinate[] = [0, 1, 2];\n    const all: SudokuBox[][] = [[], [], []];\n    allBoxCoordinates.forEach(x => {\n      allBoxCoordinates.forEach(y => {\n        all[x][y] = new SudokuBox(x, y);\n      });\n    });\n    return all;\n  }\n\n  static createByPosition(postion: SudokuPosition) {\n    const x = postion.getXCoordinate();\n    const y = postion.getYCoordinate();\n    const boxXCoordinate = this.boxCoordinateFor(x);\n    const boxYCoordinate = this.boxCoordinateFor(y);\n    return this.allInstances[boxXCoordinate][boxYCoordinate];\n  }\n\n  private static boxCoordinateFor(\n    coordinate: SudokuXCoordinate | SudokuYCoordinate\n  ) {\n    if (coordinate === 0 || coordinate === 1 || coordinate === 2) {\n      return 0;\n    } else if (coordinate === 3 || coordinate === 4 || coordinate === 5) {\n      return 1;\n    } else {\n      return 2;\n    }\n  }\n\n  private static sudokuCoordinateFor(\n    coordinate: BoxCoordinate\n  ): Array<SudokuXCoordinate | SudokuYCoordinate> {\n    if (coordinate === 0) {\n      return [0, 1, 2];\n    } else if (coordinate === 1) {\n      return [3, 4, 5];\n    } else {\n      return [6, 7, 8];\n    }\n  }\n\n  static create(x: number, y: number) {\n    return this.allInstances[x][y];\n  }\n\n  allSudokuPositionInThisBox() {\n    let result: SudokuPosition[] = [];\n    SudokuBox.sudokuCoordinateFor(this.y).forEach(yC => {\n      SudokuBox.sudokuCoordinateFor(this.x).forEach(xC => {\n        const position = new SudokuPosition(xC, yC);\n        result.push(position);\n      });\n    });\n    return result;\n  }\n\n  toString() {\n    return \"Box: [\" + this.x + \",\" + this.y + \"]\";\n  }\n}\n","enum SudokuEventType {\n  CANT_BE,\n  NUMBER_FOUND\n}\nexport default SudokuEventType;\n","import SudokuPosition from \"./SudokuPosition\";\nimport SudokuEventType from \"./SudokuEventType\";\nimport SudokuNumber from \"./SudokuNumber\";\n\nexport default class CantBeFoundEvent {\n  readonly type: SudokuEventType = SudokuEventType.CANT_BE;\n  readonly position: SudokuPosition;\n  readonly number: SudokuNumber;\n  readonly from: string;\n\n  constructor(postion: SudokuPosition, number: SudokuNumber, from: string) {\n    this.position = postion;\n    this.number = number;\n    this.from = from;\n  }\n\n  getNumber() {\n    return this.number;\n  }\n\n  getPosition() {\n    return this.position;\n  }\n\n  getFrom() {\n    return this.from;\n  }\n}\n","import SudokuBox from \"../../sudoku/SudokuBox\";\nimport CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport NumberFound2CantBe from \"./NumberFound2CantBe\";\n\nexport default class BoxCantBeRule implements NumberFound2CantBe {\n  private readonly ruleName = \"BoxCantBeRule\";\n\n  finderLogic(numberFoundEvent: NumberFoundEvent) {\n    const result = [];\n    const box = SudokuBox.createByPosition(numberFoundEvent.getPosition());\n\n    for (let position of box.allSudokuPositionInThisBox()) {\n      if (\n        position.getYCoordinate() !==\n          numberFoundEvent.getPosition().getYCoordinate() ||\n        position.getXCoordinate() !==\n          numberFoundEvent.getPosition().getXCoordinate()\n      ) {\n        result.push(\n          new CantBeFoundEvent(\n            position,\n            numberFoundEvent.getNumber(),\n            this.ruleName\n          )\n        );\n      }\n    }\n\n    return result;\n  }\n}\n","import CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport NumberFound2CantBe from \"./NumberFound2CantBe\";\nimport SudokuYCoordinate from \"../../sudoku/SudokuYCoordinate\";\n\nexport default class HorizontalCantBeRule implements NumberFound2CantBe {\n  private readonly name = \"HorizontalCantBeRule\";\n\n  finderLogic(numberFoundEvent: NumberFoundEvent) {\n    const result: CantBeFoundEvent[] = [];\n    const yCoordinates: SudokuYCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n\n    let xk = numberFoundEvent.getPosition().getXCoordinate();\n    yCoordinates.forEach(yk => {\n      if (yk !== numberFoundEvent.getPosition().getYCoordinate()) {\n        result.push(\n          new CantBeFoundEvent(\n            new SudokuPosition(xk, yk),\n            numberFoundEvent.getNumber(),\n            this.name\n          )\n        );\n      }\n    });\n\n    return result;\n  }\n}\n","import CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport NumberFound2CantBe from \"./NumberFound2CantBe\";\nimport SudokuXCoordinate from \"../../sudoku/SudokuXCoordinate\";\n\nexport default class VerticalCantBeRule implements NumberFound2CantBe {\n  private readonly name = \"VerticalCantBeRule\";\n\n  finderLogic(numberFoundEvent: NumberFoundEvent) {\n    const result: CantBeFoundEvent[] = [];\n    const xCoordinates: SudokuXCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n\n    let yk = numberFoundEvent.getPosition().getYCoordinate();\n    xCoordinates.forEach(xk => {\n      if (xk !== numberFoundEvent.getPosition().getXCoordinate()) {\n        result.push(\n          new CantBeFoundEvent(\n            new SudokuPosition(xk, yk),\n            numberFoundEvent.getNumber(),\n            this.name\n          )\n        );\n      }\n    });\n    return result;\n  }\n}\n","import CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport NumberFound2CantBe from \"./NumberFound2CantBe\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\n\nexport default class OnePositionCantBeRule implements NumberFound2CantBe {\n  private readonly name = \"OnePositionCantBeRule\";\n\n  finderLogic(numberFoundEvent: NumberFoundEvent) {\n    const result: CantBeFoundEvent[] = [];\n    const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    numbers.forEach(i => {\n      if (i !== numberFoundEvent.getNumber()) {\n        result.push(\n          new CantBeFoundEvent(numberFoundEvent.getPosition(), i, this.name)\n        );\n      }\n    });\n    return result;\n  }\n}\n","import SudokuPosition from \"./SudokuPosition\";\nimport SudokuEventType from \"./SudokuEventType\";\nimport SudokuNumber from \"./SudokuNumber\";\n\nexport default class NumberFoundEvent {\n  readonly type = SudokuEventType.NUMBER_FOUND;\n  readonly position: SudokuPosition;\n  readonly number: SudokuNumber;\n  readonly from: string;\n\n  constructor(position: SudokuPosition, number: SudokuNumber, from: string) {\n    this.position = position;\n    this.number = number;\n    this.from = from;\n  }\n\n  getNumber() {\n    return this.number;\n  }\n\n  getPosition() {\n    return this.position;\n  }\n\n  getFrom() {\n    return this.from;\n  }\n}\n","import SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport CantBe2NumberFound from \"./CantBe2NumberFound\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\nimport SudokuYCoordinate from \"../../sudoku/SudokuYCoordinate\";\n\nexport default class OnlyOnePlaceHorizontalLine implements CantBe2NumberFound {\n  /**\n   * Es wird für jede Zeile(0-8) für jede Zahl(1-9) gespeichert, wo sie nicht hin darf.\n   */\n  private readonly memory: Map<\n    number,\n    Map<SudokuNumber, Array<SudokuPosition>>\n  >;\n  private readonly name = \"OnlyOnePlaceHorizontalLine\";\n\n  constructor() {\n    this.memory = OnlyOnePlaceHorizontalLine.initMemory();\n  }\n\n  private static initMemory() {\n    const memory = new Map<number, Map<SudokuNumber, Array<SudokuPosition>>>();\n    const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\n    for (let x: number = 0; x < 9; x++) {\n      let map1 = new Map<SudokuNumber, Array<SudokuPosition>>();\n      numbers.forEach(i => {\n        map1.set(i, []);\n      });\n      memory.set(x, map1);\n    }\n    return memory;\n  }\n\n  finderLogic(cantBes: Array<CantBeFoundEvent>): Array<NumberFoundEvent> {\n    const result: Array<NumberFoundEvent> = [];\n    cantBes.forEach(cantBe => {\n      const canBeForNumberInLine =\n        this.memory\n          .get(cantBe.getPosition().getXCoordinate())\n          ?.get(cantBe.getNumber()) || []; // TODO handle undefine\n      if (\n        !canBeForNumberInLine.find(\n          it =>\n            it.getXCoordinate() === cantBe.getPosition().getXCoordinate() &&\n            it.getYCoordinate() === cantBe.getPosition().getYCoordinate()\n        )\n      ) {\n        canBeForNumberInLine.push(cantBe.getPosition());\n        if (canBeForNumberInLine.length === 8) {\n          result.push(\n            new NumberFoundEvent(\n              OnlyOnePlaceHorizontalLine.onlyPossiblePosition(\n                canBeForNumberInLine\n              ),\n              cantBe.getNumber(),\n              this.name\n            )\n          );\n        }\n      }\n    });\n    return result;\n  }\n\n  private static onlyPossiblePosition(\n    canBeForNumberInLine: SudokuPosition[]\n  ): SudokuPosition {\n    const yCoordinates: SudokuYCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n    for (let i = 0; i < yCoordinates.length; i++) {\n      let yCoordinate = yCoordinates[i];\n      if (\n        !canBeForNumberInLine.find(it => it.getYCoordinate() === yCoordinate)\n      ) {\n        return new SudokuPosition(\n          canBeForNumberInLine[0].getXCoordinate(),\n          yCoordinate\n        );\n      }\n    }\n    throw new Error(\"should not happen\");\n  }\n}\n","import SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport CantBe2NumberFound from \"./CantBe2NumberFound\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\nimport SudokuXCoordinate from \"../../sudoku/SudokuXCoordinate\";\nimport SudokuYCoordinate from \"../../sudoku/SudokuYCoordinate\";\n\nexport default class OnlyOnePlaceVerticalLine implements CantBe2NumberFound {\n  /**\n   * Es wird für jede Reihe(0-8) für jede Zahl(1-9) gespeichert, wo sie nicht hin darf.\n   */\n  private readonly memory: Map<\n    SudokuYCoordinate,\n    Map<SudokuNumber, Array<SudokuPosition>>\n  >;\n  private readonly name = \"OnlyOnePlaceVerticalLine\";\n\n  constructor() {\n    this.memory = OnlyOnePlaceVerticalLine.initMemory();\n  }\n\n  static initMemory() {\n    const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    const sudokuYCoordinates: SudokuYCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n\n    const memory = new Map<\n      SudokuYCoordinate,\n      Map<SudokuNumber, Array<SudokuPosition>>\n    >();\n    sudokuYCoordinates.forEach(x => {\n      let map1 = new Map<SudokuNumber, Array<SudokuPosition>>();\n      numbers.forEach(i => {\n        map1.set(i, []);\n      });\n      memory.set(x, map1);\n    });\n    return memory;\n  }\n\n  finderLogic(cantBes: Array<CantBeFoundEvent>): Array<NumberFoundEvent> {\n    const result: Array<NumberFoundEvent> = [];\n    cantBes.forEach(cantBe => {\n      const canBeForNumberInLine =\n        this.memory\n          .get(cantBe.getPosition().getYCoordinate())\n          ?.get(cantBe.getNumber()) || []; // TODO handle undefined\n      if (\n        !canBeForNumberInLine.find(\n          it =>\n            it.getXCoordinate() === cantBe.getPosition().getXCoordinate() &&\n            it.getYCoordinate() === cantBe.getPosition().getYCoordinate()\n        )\n      ) {\n        canBeForNumberInLine.push(cantBe.getPosition());\n        if (canBeForNumberInLine.length === 8) {\n          result.push(\n            new NumberFoundEvent(\n              OnlyOnePlaceVerticalLine.onlyPossiblePosition(\n                canBeForNumberInLine\n              ),\n              cantBe.getNumber(),\n              this.name\n            )\n          );\n        }\n      }\n    });\n    return result;\n  }\n\n  private static onlyPossiblePosition(\n    canBeForNumberInLine: SudokuPosition[]\n  ): SudokuPosition {\n    const xCoordinates: SudokuXCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n    for (let i = 0; i < xCoordinates.length; i++) {\n      let xCoordinate = xCoordinates[i];\n      if (\n        !canBeForNumberInLine.find(it => it.getXCoordinate() === xCoordinate)\n      ) {\n        return new SudokuPosition(\n          xCoordinate,\n          canBeForNumberInLine[0].getYCoordinate()\n        );\n      }\n    }\n    throw new Error(\"should not happen\");\n  }\n}\n","import SudokuBox from \"../../sudoku/SudokuBox\";\nimport SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport CantBe2NumberFound from \"./CantBe2NumberFound\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\n\nfunction samePosition(one: SudokuPosition, two: SudokuPosition) {\n  return (\n    one.getXCoordinate() === two.getXCoordinate() &&\n    one.getYCoordinate() === two.getYCoordinate()\n  );\n}\n\nexport default class OnlyOnePlaceBox implements CantBe2NumberFound {\n  /**\n   * Es wird für jede Box für jede Zahl(1-9) gespeichert, wo sie nicht hin darf.\n   */\n  private readonly memory: Map<\n    SudokuBox,\n    Map<SudokuNumber, Array<SudokuPosition>>\n  > = OnlyOnePlaceBox.init();\n  private readonly name = \"OnlyOnePlaceBox\";\n\n  private static init() {\n    const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    const memory = new Map<\n      SudokuBox,\n      Map<SudokuNumber, Array<SudokuPosition>>\n    >();\n    for (let x = 0; x < 3; x++) {\n      for (let y = 0; y < 3; y++) {\n        let map1 = new Map<SudokuNumber, Array<SudokuPosition>>();\n        numbers.forEach(i => {\n          map1.set(i, []);\n        });\n        memory.set(SudokuBox.create(x, y), map1);\n      }\n    }\n    return memory;\n  }\n\n  finderLogic(cantBes: Array<CantBeFoundEvent>) {\n    const results: NumberFoundEvent[] = [];\n    for (let info of cantBes) {\n      let position = info.getPosition();\n      let nTNumber = info.getNumber();\n      let box: SudokuBox = SudokuBox.createByPosition(position);\n\n      const notHeres = this.memory.get(box)?.get(nTNumber);\n      if (notHeres && !notHeres.find(it => samePosition(position, it))) {\n        notHeres.push(position);\n        if (notHeres.length === 8) {\n          box.allSudokuPositionInThisBox().forEach(newPos => {\n            if (!notHeres.find(it => samePosition(newPos, it))) {\n              results.push(new NumberFoundEvent(newPos, nTNumber, this.name)); //FIXME\n            }\n          });\n        }\n      }\n    }\n    return results;\n  }\n}\n","import CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport CantBe2NumberFound from \"./CantBe2NumberFound\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\n\nexport default class OnePositionFinder implements CantBe2NumberFound {\n  private readonly notThisNumber: boolean[][][] = OnePositionFinder.createBoolean3dArray();\n  private readonly name = \"OnePositionFinder\";\n\n  finderLogic(cantBes: CantBeFoundEvent[]) {\n    const results: NumberFoundEvent[] = [];\n    for (let event of cantBes) {\n      const position = event.getPosition();\n      const nTNumber = event.getNumber();\n      this.notThisNumber[position.getXCoordinate()][position.getYCoordinate()][\n        nTNumber\n      ] = true;\n\n      let anzFalse = 0;\n      let lastFalsePosition: SudokuNumber | null = null;\n      const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\n      numbers.forEach(i => {\n        if (\n          !this.notThisNumber[position.getXCoordinate()][\n            position.getYCoordinate()\n          ][i]\n        ) {\n          anzFalse++;\n          lastFalsePosition = i;\n        }\n      });\n      if (anzFalse === 1 && lastFalsePosition !== null) {\n        results.push(\n          new NumberFoundEvent(position, lastFalsePosition, this.name)\n        );\n      }\n    }\n    return results;\n  }\n\n  private static createBoolean3dArray() {\n    const array3d: boolean[][][] = [];\n\n    for (let i = 0; i < 9; i++) {\n      array3d[i] = [];\n      for (let j = 0; j < 9; j++) {\n        array3d[i][j] = [];\n        for (let k = 0; k < 9; k++) {\n          array3d[i][j][k] = false;\n        }\n      }\n    }\n\n    return array3d;\n  }\n}\n","import SudokuEventType from \"./SudokuEventType\";\nimport NumberFoundEvent from \"./NumberFoundEvent\";\n\nexport default class EventFilter {\n  private numberFound: number[][] = [[], [], [], [], [], [], [], [], []];\n\n  removeAlreadySeen(toFilter: NumberFoundEvent[]) {\n    const filtered = [];\n\n    for (const numberFoundEvent of toFilter) {\n      if (numberFoundEvent.type === SudokuEventType.NUMBER_FOUND) {\n        if (\n          !this.numberFound[numberFoundEvent.getPosition().getXCoordinate()][\n            numberFoundEvent.getPosition().getYCoordinate()\n          ]\n        ) {\n          this.numberFound[numberFoundEvent.getPosition().getXCoordinate()][\n            numberFoundEvent.getPosition().getYCoordinate()\n          ] = numberFoundEvent.getNumber();\n          filtered.push(numberFoundEvent);\n        }\n        // TODO validate number in case of alerdy seen\n      } else {\n        // filter CANT BES\n        filtered.push(numberFoundEvent);\n      }\n    }\n    return filtered;\n  }\n}\n","import BoxCantBeRule from \"../finder/numberFound2cantBe/BoxCantBeRule\";\nimport HorizontalCantBeRule from \"../finder/numberFound2cantBe/HorizontalCantBeRule\";\nimport VerticalCantBeRule from \"../finder/numberFound2cantBe/VerticalCantBeRule\";\nimport OnePositionCantBeRule from \"../finder/numberFound2cantBe/OnePositionCantBeRule\";\nimport OnlyOnePlaceHorizontalLine from \"../finder/cantBe2NumberFound/OnlyOnePlaceHorizontalLine\";\nimport OnlyOnePlaceVerticalLine from \"../finder/cantBe2NumberFound/OnlyOnePlaceVerticalLine\";\nimport OnlyOnePlaceBox from \"../finder/cantBe2NumberFound/OnlyOnePlaceBox\";\nimport OnePositionFinder from \"../finder/cantBe2NumberFound/OnePositionFinder\";\nimport EventFilter from \"./EventFilter\";\nimport CantBeFoundEvent from \"./CantBeFoundEvent\";\nimport NumberFound2CantBe from \"../finder/numberFound2cantBe/NumberFound2CantBe\";\nimport NumberFoundEvent from \"./NumberFoundEvent\";\nimport CantBe2NumberFound from \"../finder/cantBe2NumberFound/CantBe2NumberFound\";\n\nlet numberFound2cantBeRules: NumberFound2CantBe[] = [\n  new BoxCantBeRule(),\n  new HorizontalCantBeRule(),\n  new VerticalCantBeRule(),\n  new OnePositionCantBeRule()\n];\n\nlet cantBe2NumberFound: CantBe2NumberFound[] = [\n  new OnlyOnePlaceHorizontalLine(),\n  new OnlyOnePlaceVerticalLine(),\n  new OnlyOnePlaceBox(),\n  new OnePositionFinder()\n];\n\nlet eventFilter = new EventFilter();\n\nexport default class RuleOrchestration {\n  handleGivenNumber(\n    numberFoundEvent: NumberFoundEvent,\n    postMessage: (e: CantBeFoundEvent | NumberFoundEvent) => void\n  ) {\n    let foundNumbers = eventFilter.removeAlreadySeen([numberFoundEvent]);\n    do {\n      let cantBeRulesResults: CantBeFoundEvent[] = [];\n      for (const rule of numberFound2cantBeRules) {\n        for (const foundNumber of foundNumbers) {\n          cantBeRulesResults = cantBeRulesResults.concat(\n            rule.finderLogic(foundNumber)\n          );\n        }\n      }\n      cantBeRulesResults.forEach(it => {\n        postMessage(it);\n      });\n\n      foundNumbers = [];\n      for (const rule of cantBe2NumberFound) {\n        foundNumbers = foundNumbers.concat(\n          rule.finderLogic(cantBeRulesResults)\n        );\n      }\n      foundNumbers = eventFilter.removeAlreadySeen(foundNumbers);\n      foundNumbers.forEach(foundNumbers => {\n        postMessage(foundNumbers);\n      });\n    } while (foundNumbers.length > 0);\n  }\n}\n","import SudokuPosition from \"./sudoku/SudokuPosition\";\nimport RuleOrchestration from \"./sudoku/RuleOrchestration\";\nimport NumberFoundEvent from \"./sudoku/NumberFoundEvent\";\n\nlet ruleOrchestration = new RuleOrchestration();\n\n// eslint-disable-next-line no-restricted-globals\naddEventListener(\"message\", ({ data }) => {\n  console.log(\"worker got message\", data);\n\n  let sudokuEvent = new NumberFoundEvent(\n    new SudokuPosition(data.field[0], data.field[1]),\n    data.value,\n    \"USER\"\n  );\n  ruleOrchestration.handleGivenNumber(sudokuEvent, postMessage);\n});\n"],"names":["_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","prototype","SudokuPosition","xCoordinate","yCoordinate","this","_arrayLikeToArray","arr","len","arr2","Array","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","isArray","minLen","n","toString","call","slice","constructor","name","from","test","F","s","done","value","e","_e","f","err","normalCompletion","didErr","step","next","_e2","SudokuEventType","SudokuBox","x","y","Error","allInstances","result","sudokuCoordinateFor","forEach","yC","xC","position","push","allBoxCoordinates","all","postion","getXCoordinate","getYCoordinate","boxXCoordinate","boxCoordinateFor","boxYCoordinate","coordinate","createAll","CantBeFoundEvent","number","type","BoxCantBeRule","ruleName","numberFoundEvent","createByPosition","getPosition","allSudokuPositionInThisBox","getNumber","HorizontalCantBeRule","xk","yk","VerticalCantBeRule","OnePositionCantBeRule","NumberFoundEvent","OnlyOnePlaceHorizontalLine","memory","initMemory","cantBes","cantBe","canBeForNumberInLine","get","find","onlyPossiblePosition","Map","numbers","map1","set","yCoordinates","OnlyOnePlaceVerticalLine","xCoordinates","samePosition","one","two","OnlyOnePlaceBox","init","results","info","nTNumber","box","notHeres","newPos","create","OnePositionFinder","notThisNumber","createBoolean3dArray","event","anzFalse","lastFalsePosition","array3d","j","k","EventFilter","numberFound","toFilter","filtered","numberFound2cantBeRules","cantBe2NumberFound","eventFilter","ruleOrchestration","postMessage","foundNumbers","removeAlreadySeen","cantBeRulesResults","rule","foundNumber","concat","finderLogic","addEventListener","data","console","log","sudokuEvent","field","handleGivenNumber"],"sourceRoot":""}