{"version":3,"file":"static/js/sudoku.worker.f7e28c9f.worker.js","mappings":"mBAGe,MAAMA,EAMnB,gBAAeC,GACb,MACMC,EAAuC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAChEC,EAA0B,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAMjE,MAR6C,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAGtDC,SAASC,IACvBH,EAAgBE,SAASE,IACvBH,EAAIE,GAAGC,GAAK,IAAIN,EAAeK,EAAGC,EAAE,GACpC,IAEGH,CACT,CAEA,SAAcI,CACZC,EACAC,GAEA,OAAOT,EAAeU,aAAaF,GAAaC,EAClD,CAEQE,WAAAA,CACNH,EACAC,GACC,KA3BMD,iBAAW,OACXC,iBAAW,EA2BlBG,KAAKJ,YAAcA,EACnBI,KAAKH,YAAcA,CACrB,CAEAI,cAAAA,GACE,OAAOD,KAAKJ,WACd,CAEAM,cAAAA,GACE,OAAOF,KAAKH,WACd,CAEAM,QAAAA,GACE,MAAO,SAAWH,KAAKJ,YAAc,IAAMI,KAAKH,YAAc,GAChE,CAEAO,OAAAA,GACE,MAAO,IAAMJ,KAAKJ,YAAc,KAAOI,KAAKH,YAAc,GAC5D,EA/CmBT,EAIJU,aAAmCV,EAAeC,YCDpD,MAAMgB,EAMXN,WAAAA,CAAYN,EAAkBC,GACpC,GADuD,KALxCD,OAAC,OACDC,OAAC,EAKZD,EAAI,GAAKC,EAAI,GAAKD,EAAI,GAAKC,EAAI,EACjC,MAAM,IAAIY,MAAM,sBAAwBb,EAAI,OAASC,GAEvDM,KAAKP,EAAIA,EACTO,KAAKN,EAAIA,CACX,CAEAa,IAAAA,GACE,OAAOP,KAAKP,CACd,CAEAe,IAAAA,GACE,OAAOR,KAAKN,CACd,CAEA,aAAOe,GACL,OAAOT,KAAKF,aAAaY,MAC3B,CAEA,gBAAerB,GACb,MAAMsB,EAAqC,CAAC,EAAG,EAAG,GAC5CpB,EAAqB,CAAC,GAAI,GAAI,IAMpC,OALAoB,EAAkBnB,SAASC,IACzBkB,EAAkBnB,SAASE,IACzBH,EAAIE,GAAGC,GAAK,IAAIW,EAAUZ,EAAGC,EAAE,GAC/B,IAEGH,CACT,CAEA,uBAAOqB,CAAiBC,GACtB,MAAMpB,EAAIoB,EAAQZ,iBACZP,EAAImB,EAAQX,iBACZY,EAAiBd,KAAKe,iBAAiBtB,GACvCuB,EAAiBhB,KAAKe,iBAAiBrB,GAC7C,OAAOM,KAAKF,aAAagB,GAAgBE,EAC3C,CAEA,uBAAeD,CACbE,GAEA,OAAmB,IAAfA,GAAmC,IAAfA,GAAmC,IAAfA,EACnC,EACiB,IAAfA,GAAmC,IAAfA,GAAmC,IAAfA,EAC1C,EAEA,CAEX,CAEA,0BAAeC,CACbD,GAEA,OAAmB,IAAfA,EACK,CAAC,EAAG,EAAG,GACU,IAAfA,EACF,CAAC,EAAG,EAAG,GAEP,CAAC,EAAG,EAAG,EAElB,CAEA,aAAOE,CAAO1B,EAAWC,GACvB,OAAOM,KAAKF,aAAaL,GAAGC,EAC9B,CAEA0B,0BAAAA,GACE,IAAIC,EAA2B,GAO/B,OANAhB,EAAUa,oBAAoBlB,KAAKN,GAAGF,SAAS8B,IAC7CjB,EAAUa,oBAAoBlB,KAAKP,GAAGD,SAAS+B,IAC7C,MAAMC,EAAWpC,EAAeO,GAAG4B,EAAID,GACvCD,EAAOI,KAAKD,EAAS,GACrB,IAEGH,CACT,CAEAlB,QAAAA,GACE,MAAO,SAAWH,KAAKP,EAAI,IAAMO,KAAKN,EAAI,GAC5C,E,IC5FGgC,EDMgBrB,EAIJP,aAA8BO,EAAUhB,YCVrC,SAAfqC,GAAAA,EAAAA,EAAe,qBAAfA,EAAAA,EAAe,gCAAfA,IAAAA,EAAe,KAIpB,UCAe,MAAMC,EAMnB5B,WAAAA,CAAYc,EAAyBe,EAAsBC,GAAe,KALjEC,KAAwBJ,EAAgBK,QAAQ,KAChDP,cAAQ,OACRI,YAAM,OACNC,UAAI,EAGX7B,KAAKwB,SAAWX,EAChBb,KAAK4B,OAASA,EACd5B,KAAK6B,KAAOA,CACd,CAEAG,SAAAA,GACE,OAAOhC,KAAK4B,MACd,CAEAK,WAAAA,GACE,OAAOjC,KAAKwB,QACd,CAEAU,OAAAA,GACE,OAAOlC,KAAK6B,IACd,ECrBa,MAAMM,EAA4CpC,WAAAA,GAAA,KAC9CqC,SAAW,eAAgB,CAE5CC,WAAAA,CAAYC,GACV,MAAMjB,EAAS,GACTkB,EAAMlC,EAAUO,iBAAiB0B,EAAiBL,eAExD,IAAK,IAAIT,KAAYe,EAAInB,6BAErBI,EAAStB,mBACPoC,EAAiBL,cAAc/B,kBACjCsB,EAASvB,mBACPqC,EAAiBL,cAAchC,kBAEjCoB,EAAOI,KACL,IAAIE,EACFH,EACAc,EAAiBN,YACjBhC,KAAKoC,WAMb,OAAOf,CACT,ECxBa,MAAMmB,EAAmDzC,WAAAA,GAAA,KACrD0C,KAAO,sBAAuB,CAE/CJ,WAAAA,CAAYC,GACV,MAAMjB,EAA6B,GAGnC,IAAIqB,EAAKJ,EAAiBL,cAAchC,iBAaxC,MAf0C,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAGtDT,SAASmD,IAChBA,IAAOL,EAAiBL,cAAc/B,kBACxCmB,EAAOI,KACL,IAAIE,EACFvC,EAAeO,GAAG+C,EAAIC,GACtBL,EAAiBN,YACjBhC,KAAKyC,MAGX,IAGKpB,CACT,ECrBa,MAAMuB,EAAiD7C,WAAAA,GAAA,KACnD0C,KAAO,oBAAqB,CAE7CJ,WAAAA,CAAYC,GACV,MAAMjB,EAA6B,GAGnC,IAAIsB,EAAKL,EAAiBL,cAAc/B,iBAYxC,MAd0C,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAGtDV,SAASkD,IAChBA,IAAOJ,EAAiBL,cAAchC,kBACxCoB,EAAOI,KACL,IAAIE,EACFvC,EAAeO,GAAG+C,EAAIC,GACtBL,EAAiBN,YACjBhC,KAAKyC,MAGX,IAEKpB,CACT,ECrBa,MAAMwB,EAAoD9C,WAAAA,GAAA,KACtD0C,KAAO,uBAAwB,CAEhDJ,WAAAA,CAAYC,GACV,MAAMjB,EAA6B,GASnC,MARgC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACjD7B,SAASsD,IACXA,IAAMR,EAAiBN,aACzBX,EAAOI,KACL,IAAIE,EAAiBW,EAAiBL,cAAea,EAAG9C,KAAKyC,MAEjE,IAEKpB,CACT,ECfa,MAAM0B,EAMnBhD,WAAAA,CAAYyB,EAA0BI,EAAsBC,GAAe,KALlEC,KAAOJ,EAAgBsB,aAAa,KACpCxB,cAAQ,OACRI,YAAM,OACNC,UAAI,EAGX7B,KAAKwB,SAAWA,EAChBxB,KAAK4B,OAASA,EACd5B,KAAK6B,KAAOA,CACd,CAEAG,SAAAA,GACE,OAAOhC,KAAK4B,MACd,CAEAK,WAAAA,GACE,OAAOjC,KAAKwB,QACd,CAEAU,OAAAA,GACE,OAAOlC,KAAK6B,IACd,ECnBa,MAAMoB,EAUnBlD,WAAAA,GAAe,KANEmD,YAAM,OAINT,KAAO,6BAGtBzC,KAAKkD,OAASD,EAA2BE,YAC3C,CAEA,iBAAeA,GACb,MAAMD,EAAS,IAAIE,IACbC,EAA0B,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAEzD,IAAK,IAAI5D,EAAY,EAAGA,EAAI,EAAGA,IAAK,CAClC,IAAI6D,EAAO,IAAIF,IACfC,EAAQ7D,SAASsD,IACfQ,EAAKC,IAAIT,EAAG,GAAG,IAEjBI,EAAOK,IAAI9D,EAAG6D,EAChB,CACA,OAAOJ,CACT,CAEAb,WAAAA,CAAYmB,GACV,MAAMnC,EAAkC,GA2BxC,OA1BAmC,EAAQhE,SAASiE,IAAY,IAADC,EAC1B,MAAMC,GAEyC,QAD7CD,EAAA1D,KAAKkD,OACFU,IAAIH,EAAOxB,cAAchC,yBAAiB,IAAAyD,OAAA,EAD7CA,EAEIE,IAAIH,EAAOzB,eAAgB,GAE9B2B,EAAqBE,MACnBC,GACCA,EAAG7D,mBAAqBwD,EAAOxB,cAAchC,kBAC7C6D,EAAG5D,mBAAqBuD,EAAOxB,cAAc/B,qBAGjDyD,EAAqBlC,KAAKgC,EAAOxB,eACG,IAAhC0B,EAAqBI,QACvB1C,EAAOI,KACL,IAAIsB,EACFE,EAA2Be,qBACzBL,GAEFF,EAAOzB,YACPhC,KAAKyC,OAIb,IAEKpB,CACT,CAEA,2BAAe2C,CACbL,GAEA,MAAMM,EAAoC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnE,IAAK,IAAInB,EAAI,EAAGA,EAAImB,EAAaF,OAAQjB,IAAK,CAC5C,IAAIjD,EAAcoE,EAAanB,GAC/B,IACGa,EAAqBE,MAAMC,GAAOA,EAAG5D,mBAAqBL,IAE3D,OAAOT,EAAeO,GACpBgE,EAAqB,GAAG1D,iBACxBJ,EAGN,CACA,MAAM,IAAIS,MAAM,oBAClB,EC1Ea,MAAM4D,EAUnBnE,WAAAA,GAAe,KANEmD,YAAM,OAINT,KAAO,2BAGtBzC,KAAKkD,OAASgB,EAAyBf,YACzC,CAEA,iBAAOA,GACL,MAAME,EAA0B,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAGnDH,EAAS,IAAIE,IAWnB,MAbgD,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAMtD5D,SAASC,IAC1B,IAAI6D,EAAO,IAAIF,IACfC,EAAQ7D,SAASsD,IACfQ,EAAKC,IAAIT,EAAG,GAAG,IAEjBI,EAAOK,IAAI9D,EAAG6D,EAAK,IAEdJ,CACT,CAEAb,WAAAA,CAAYmB,GACV,MAAMnC,EAAkC,GA2BxC,OA1BAmC,EAAQhE,SAASiE,IAAY,IAADC,EAC1B,MAAMC,GAEyC,QAD7CD,EAAA1D,KAAKkD,OACFU,IAAIH,EAAOxB,cAAc/B,yBAAiB,IAAAwD,OAAA,EAD7CA,EAEIE,IAAIH,EAAOzB,eAAgB,GAE9B2B,EAAqBE,MACnBC,GACCA,EAAG7D,mBAAqBwD,EAAOxB,cAAchC,kBAC7C6D,EAAG5D,mBAAqBuD,EAAOxB,cAAc/B,qBAGjDyD,EAAqBlC,KAAKgC,EAAOxB,eACG,IAAhC0B,EAAqBI,QACvB1C,EAAOI,KACL,IAAIsB,EACFmB,EAAyBF,qBACvBL,GAEFF,EAAOzB,YACPhC,KAAKyC,OAIb,IAEKpB,CACT,CAEA,2BAAe2C,CACbL,GAEA,MAAMQ,EAAoC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnE,IAAK,IAAIrB,EAAI,EAAGA,EAAIqB,EAAaJ,OAAQjB,IAAK,CAC5C,IAAIlD,EAAcuE,EAAarB,GAC/B,IACGa,EAAqBE,MAAMC,GAAOA,EAAG7D,mBAAqBL,IAE3D,OAAOR,EAAeO,GACpBC,EACA+D,EAAqB,GAAGzD,iBAG9B,CACA,MAAM,IAAII,MAAM,oBAClB,EChFF,SAAS8D,EAAaC,EAAqBC,GACzC,OACED,EAAIpE,mBAAqBqE,EAAIrE,kBAC7BoE,EAAInE,mBAAqBoE,EAAIpE,gBAEjC,CAEe,MAAMqE,EAA8CxE,WAAAA,GAAA,KAIhDmD,OAGbqB,EAAgBC,OAAO,KACV/B,KAAO,iBAAkB,CAE1C,WAAe+B,GACb,MAAMnB,EAA0B,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnDH,EAAS,IAAIE,IAInB,IAAK,IAAI3D,EAAI,EAAGA,EAAI,EAAGA,IACrB,IAAK,IAAIC,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC1B,IAAI4D,EAAO,IAAIF,IACfC,EAAQ7D,SAASsD,IACfQ,EAAKC,IAAIT,EAAG,GAAG,IAEjBI,EAAOK,IAAIlD,EAAUc,OAAO1B,EAAGC,GAAI4D,EACrC,CAEF,OAAOJ,CACT,CAEAb,WAAAA,CAAYmB,GACV,MAAMiB,EAA8B,GACpC,IAAK,IAAIC,KAAQlB,EAAS,CAAC,IAADE,EACxB,IAAIlC,EAAWkD,EAAKzC,cAChB0C,EAAWD,EAAK1C,YAChBO,EAAiBlC,EAAUO,iBAAiBY,GAEhD,MAAMoD,EAA+B,QAAvBlB,EAAG1D,KAAKkD,OAAOU,IAAIrB,UAAI,IAAAmB,OAAA,EAApBA,EAAsBE,IAAIe,GACvCC,IAAaA,EAASf,MAAMC,GAAOM,EAAa5C,EAAUsC,OAC5Dc,EAASnD,KAAKD,GACU,IAApBoD,EAASb,QACXxB,EAAInB,6BAA6B5B,SAASqF,IACnCD,EAASf,MAAMC,GAAOM,EAAaS,EAAQf,MAC9CW,EAAQhD,KAAK,IAAIsB,EAAiB8B,EAAQF,EAAU3E,KAAKyC,MAC3D,IAIR,CACA,OAAOgC,CACT,ECzDa,MAAMK,EAAgD/E,WAAAA,GAAA,KAClDgF,cACfD,EAAkBE,uBAAuB,KAC1BvC,KAAO,mBAAoB,CAE5CJ,WAAAA,CAAYmB,GACV,MAAMiB,EAA8B,GACpC,IAAK,IAAIQ,KAASzB,EAAS,CACzB,MAAMhC,EAAWyD,EAAMhD,cACjB0C,EAAWM,EAAMjD,YACvBhC,KAAK+E,cAAcvD,EAASvB,kBAAkBuB,EAAStB,kBACrDyE,IACE,EAEJ,IAAIO,EAAW,EACXC,EAAyC,KACb,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAEjD3F,SAASsD,IAEZ9C,KAAK+E,cAAcvD,EAASvB,kBAC3BuB,EAAStB,kBACT4C,KAEFoC,IACAC,EAAoBrC,EACtB,IAEe,IAAboC,GAAwC,OAAtBC,GACpBV,EAAQhD,KACN,IAAIsB,EAAiBvB,EAAU2D,EAAmBnF,KAAKyC,MAG7D,CACA,OAAOgC,CACT,CAEA,2BAAeO,GACb,MAAMI,EAAyB,GAE/B,IAAK,IAAItC,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC1BsC,EAAQtC,GAAK,GACb,IAAK,IAAIuC,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC1BD,EAAQtC,GAAGuC,GAAK,GAChB,IAAK,IAAIC,EAAI,EAAGA,EAAI,EAAGA,IACrBF,EAAQtC,GAAGuC,GAAGC,IAAK,CAEvB,CACF,CAEA,OAAOF,CACT,ECrDa,MAAMG,EAAYxF,WAAAA,GAAA,KACvByF,YAA0B,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,CAEvEC,iBAAAA,CAAkBC,GAChB,MAAMC,EAAW,GAEjB,IAAK,MAAMrD,KAAoBoD,EACzBpD,EAAiBR,OAASJ,EAAgBsB,aAEzChD,KAAKwF,YAAYlD,EAAiBL,cAAchC,kBAC/CqC,EAAiBL,cAAc/B,oBAGjCF,KAAKwF,YAAYlD,EAAiBL,cAAchC,kBAC9CqC,EAAiBL,cAAc/B,kBAC7BoC,EAAiBN,YACrB2D,EAASlE,KAAKa,IAKhBqD,EAASlE,KAAKa,GAGlB,OAAOqD,CACT,ECvBK,SAASC,EACdhB,EACArC,GAEA,OAAOA,EACJnB,6BACAyE,QAAQC,GAAQlB,EAASmB,QAAQD,GAAO,GAC7C,CAEO,SAASE,EACdC,GAEA,OAAOC,EAASD,EAAkBE,KAAKL,GAAQA,EAAI5F,mBACrD,CAEO,SAASkG,EACdH,GAEA,OAAOC,EAASD,EAAkBE,KAAKL,GAAQA,EAAI7F,mBACrD,CAEA,SAASiG,EAAYG,GACnB,OAAOA,EAAKR,QAAO,CAACS,EAAGxD,EAAGyD,IAASzD,IAAMyD,EAAKR,QAAQO,IACxD,CCZe,MAAME,EAAyDzG,WAAAA,GAAA,KAI3DmD,OAGbsD,EAAgChC,OAAO,KAC1B/B,KAAO,iCAAkC,CAE1D,WAAe+B,GACb,MAAMnB,EAA0B,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnDH,EAAS,IAAIE,IAInB,IAAK,IAAI3D,EAAI,EAAGA,EAAI,EAAGA,IACrB,IAAK,IAAIC,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC1B,IAAI4D,EAAO,IAAIF,IACfC,EAAQ7D,SAASsD,IACfQ,EAAKC,IAAIT,EAAG,GAAG,IAEjBI,EAAOK,IAAIlD,EAAUc,OAAO1B,EAAGC,GAAI4D,EACrC,CAEF,OAAOJ,CACT,CAEAb,WAAAA,CAAYmB,GACV,MAAMiB,EAA8B,GACpC,IAAK,IAAIC,KAAQlB,EAAS,CAAC,IAADE,EACxB,IAAIlC,EAAWkD,EAAKzC,cAChB0C,EAAWD,EAAK1C,YAChBO,EAAiBlC,EAAUO,iBAAiBY,GAEhD,MAAMoD,EAA+B,QAAvBlB,EAAG1D,KAAKkD,OAAOU,IAAIrB,UAAI,IAAAmB,OAAA,EAApBA,EAAsBE,IAAIe,GAC3C,GAAIC,IAAaA,EAASf,MAAMC,IAAOM,OA3CFE,EA2CyBR,GA3C9CO,EA2CoC7C,GAzClDvB,mBAAqBqE,EAAIrE,kBAC7BoE,EAAInE,mBAAqBoE,EAAIpE,iBAHjC,IAAsBmE,EAAqBC,CA2C4B,MAC/DM,EAASnD,KAAKD,GACVoD,EAASb,QAAU,GAAKa,EAASb,QAAU,GAAG,CAChD,MAIM0C,EACJT,EAL0CJ,EAC1ChB,EACArC,IAIF,GAA+C,IAA3CkE,EAAgC1C,OAAc,CAEhD,MAAM2C,EACJC,EACEF,EAAgC,GAChC9B,EACApC,GAEJkC,EAAQhD,QAAQiF,EAClB,CACF,CAEJ,CACA,OAAOjC,CACT,EAGF,SAASkC,EACPF,EACA9B,EACApC,GAGA,MADwC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAE9D4D,KAAKvG,GACJR,EAAeO,GAAGC,EAAa6G,KAEhCZ,QAAQC,GAAQvD,EAAInB,6BAA6B2E,QAAQD,GAAO,IAChEK,KACEL,GACC,IAAInE,EACFmE,EACAnB,EACA6B,EAAgC/D,OAG1C,CCjFe,MAAMmE,EAErB7G,WAAAA,GAAA,KAImBmD,OAGb0D,EAAkCpC,OAAO,KAC5B/B,KAAO,mCAAoC,CAE5D,WAAe+B,GACb,MAAMnB,EAA0B,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACnDH,EAAS,IAAIE,IAInB,IAAK,IAAI3D,EAAI,EAAGA,EAAI,EAAGA,IACrB,IAAK,IAAIC,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC1B,IAAI4D,EAAO,IAAIF,IACfC,EAAQ7D,SAASsD,IACfQ,EAAKC,IAAIT,EAAG,GAAG,IAEjBI,EAAOK,IAAIlD,EAAUc,OAAO1B,EAAGC,GAAI4D,EACrC,CAEF,OAAOJ,CACT,CAEAb,WAAAA,CAAYmB,GACV,MAAMiB,EAA8B,GACpC,IAAK,IAAIC,KAAQlB,EAAS,CAAC,IAADE,EACxB,IAAIlC,EAAWkD,EAAKzC,cAChB0C,EAAWD,EAAK1C,YAChBO,EAAiBlC,EAAUO,iBAAiBY,GAEhD,MAAMoD,EAA+B,QAAvBlB,EAAG1D,KAAKkD,OAAOU,IAAIrB,UAAI,IAAAmB,OAAA,EAApBA,EAAsBE,IAAIe,GAC3C,GAAIC,IAAaA,EAASf,MAAMC,IAAOM,OA7CFE,EA6CyBR,GA7C9CO,EA6CoC7C,GA3ClDvB,mBAAqBqE,EAAIrE,kBAC7BoE,EAAInE,mBAAqBoE,EAAIpE,iBAHjC,IAAsBmE,EAAqBC,CA6C4B,MAC/DM,EAASnD,KAAKD,GACVoD,EAASb,QAAU,GAAKa,EAASb,QAAU,GAAG,CAChD,MAIM8C,EACJT,EAL0CR,EAC1ChB,EACArC,IAIF,GAA+C,IAA3CsE,EAAgC9C,OAAc,CAEhD,MAAM2C,EACJC,EACEE,EAAgC,GAChClC,EACApC,GAEJkC,EAAQhD,QAAQiF,EAClB,CACF,CAEJ,CACA,OAAOjC,CACT,EAGF,SAASkC,EACPE,EACAlC,EACApC,GAGA,MADwC,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GAE9D4D,KAAKtG,GACJT,EAAeO,GAAGkH,EAAiChH,KAEpDgG,QAAQC,GAAQvD,EAAInB,6BAA6B2E,QAAQD,GAAO,IAChEK,KACEL,GACC,IAAInE,EACFmE,EACAnB,EACAiC,EAAkCnE,OAG5C,CC7Fe,MAAMqE,EAGnB/G,WAAAA,GAAe,KAFEgH,qCAA+B,EAG9C/G,KAAK+G,gCAAkC,IAAI3D,IAC3C,IAAK,MAAMb,KAAOlC,EAAUI,SAAU,CACpC,MAAMuG,EAA4B,IAAI5D,IACtC,IAAK,MAAM5B,KAAYe,EAAInB,6BACzB4F,EAA0BzD,IAAI/B,EAAU,IAAIyF,IAAI,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,KAE3EjH,KAAK+G,gCAAgCxD,IAAIhB,EAAKyE,EAChD,CACF,CAEA3E,WAAAA,CAAYmB,GACV,MAAMiB,EAA8B,GAC9ByC,EAAgC,IAAID,IAG1C,IAAK,MAAMxD,KAAUD,EAAS,CAC5B,MAAMjB,EAAMlC,EAAUO,iBAAiB6C,EAAOxB,eACxCT,EAAWiC,EAAOxB,cAClBL,EAAS6B,EAAOzB,YACYhC,KAAK+G,gCAAgCnD,IAAIrB,GAC7CqB,IAAIpC,GAAW2F,OAAOvF,IAClDsF,EAAcE,IAAI7E,EAEtB,CAGA,IAAK,MAAMA,KAAO2E,EAAe,CAC/B,MAAMG,EAA4BrH,KAAK+G,gCAAgCnD,IAAIrB,GACrE+E,EAA8BC,MAAM1F,KAAKwF,EAA0BG,WAEzE,IAAK,IAAIC,EAAY,EAAGA,GAAa,EAAGA,IAAa,CACnD,MAAMC,EAAkD1H,KAAK2H,WAAWL,EAA6BG,GACrG,IAAK,MAAMG,KAASF,EAAQ,CAC1B,MAAMrE,EAAUkE,MAAM1F,KAAK+F,EAAM,GAAG,IAC9BC,EAAiBN,MAAM1F,KAAKU,EAAInB,8BAA8ByE,QAAOC,IAAQ8B,EAAME,MAAKC,IAAA,IAAEC,GAAKD,EAAA,OAAKC,IAASlC,CAAG,MACtH,IAAK,MAAMlE,KAAUyB,EACnBoB,EAAQhD,QAAQwG,EAAqCJ,EAAgBjG,GAEzE,CACF,CACF,CAEA,OAAO6C,CACT,CAEQkD,UAAAA,CAAWL,EAAoEG,GACrF,MAAMC,EAAkD,GAClDQ,EAAwDlI,KAAKmI,gBAAgBb,EAA6BG,GAEhH,IAAK,MAAMW,KAAeF,EAAc,CACtC,MAAOG,EAAUC,GAAgBF,EAAY,GACzCE,EAAaC,OAASd,GAAaW,EAAYI,OAAMC,IAAA,IAAE,CAAEpF,GAAQoF,EAAA,OAAKzI,KAAK0I,aAAarF,EAASiF,EAAa,KAChHZ,EAAOjG,KAAK2G,EAEhB,CAEA,OAAOV,CACT,CAEQS,eAAAA,CAAgBb,EAAoEG,GAC1F,GAAIA,EAAYH,EAA4BvD,OAAQ,MAAO,GAC3D,GAAkB,IAAd0D,EAAiB,OAAOH,EAA4BnB,KAAIwC,GAAQ,CAACA,KAErE,MAAMT,EAAwD,GAQ9D,OAPAZ,EAA4B9H,SAAQ,CAACmJ,EAA2CC,KAClD5I,KAAKmI,gBAAgBb,EAA4BuB,MAAMD,EAAQ,GAAInB,EAAY,GACvFjI,SAAQsJ,IAC1BZ,EAAazG,KAAK,CAACkH,KAASG,GAAoB,GAChD,IAGGZ,CACT,CAEQQ,YAAAA,CAAaK,EAAgBC,GACnC,GAAID,EAAKR,OAASS,EAAKT,KAAM,OAAO,EACpC,IAAK,MAAMU,KAAKF,EAAM,IAAKC,EAAKE,IAAID,GAAI,OAAO,EAC/C,OAAO,CACT,EAGF,SAAShB,EACPkB,EACAvH,GAEA,OAAOuH,EAAUhD,KACdL,GACC,IAAInE,EACFmE,EACAlE,EACAkF,EAA2BrE,OAGnC,CCnGe,MAAM2G,EAcXrJ,WAAAA,CAAYsJ,GAAoC,KAFvCA,oBAAc,EAG7BrJ,KAAKqJ,eAAiBA,CACxB,CAEA,aAAO5I,GACL,OAAO2I,EAAqBE,QAC9B,CAEAC,2BAAAA,GACE,MCvBK,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GDuBCpD,KAAIzG,GAAKN,EAAeO,GAAGK,KAAKqJ,eAAgB3J,IACjF,CAEA,uBAAOkB,CAAiBY,GACtB,OAAO4H,EAAqBE,SAAS9H,EAASvB,iBAChD,EA5BmBmJ,EACJE,SAAmC,CAChD,IAAIF,EAAqB,GACzB,IAAIA,EAAqB,GACzB,IAAIA,EAAqB,GACzB,IAAIA,EAAqB,GACzB,IAAIA,EAAqB,GACzB,IAAIA,EAAqB,GACzB,IAAIA,EAAqB,GACzB,IAAIA,EAAqB,GACzB,IAAIA,EAAqB,IERd,MAAMI,EAGnBzJ,WAAAA,GAAe,KAFE0J,sCAAgC,EAG/CzJ,KAAKyJ,iCAAmC,IAAIrG,IAC5C,IAAK,MAAMsG,KAAQN,EAAqB3I,SAAU,CAChD,MAAMuG,EAA4B,IAAI5D,IACtC,IAAK,MAAM5B,KAAYkI,EAAKH,8BAC1BvC,EAA0BzD,IAAI/B,EAAU,IAAIyF,IAAI,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,KAE3EjH,KAAKyJ,iCAAiClG,IAAImG,EAAM1C,EAClD,CACF,CAEA3E,WAAAA,CAAYmB,GACV,MAAMiB,EAA8B,GAC9BkF,EAA2C,IAAI1C,IAGrD,IAAK,MAAMxD,KAAUD,EAAS,CAC5B,MAAMkG,EAAON,EAAqBxI,iBAAiB6C,EAAOxB,eACpDT,EAAWiC,EAAOxB,cAClBL,EAAS6B,EAAOzB,YACYhC,KAAKyJ,iCAAiC7F,IAAI8F,GAC9C9F,IAAIpC,GAAW2F,OAAOvF,IAClD+H,EAAcvC,IAAIsC,EAEtB,CAGA,IAAK,MAAMA,KAAQC,EAAe,CAChC,MAAMtC,EAA4BrH,KAAKyJ,iCAAiC7F,IAAI8F,GACtEpC,EAA8BC,MAAM1F,KAAKwF,EAA0BG,WAEzE,IAAK,IAAIC,EAAY,EAAGA,GAAa,EAAGA,IAAa,CACnD,MAAMC,EAAkD1H,KAAK2H,WAAWL,EAA6BG,GACrG,IAAK,MAAMG,KAASF,EAAQ,CAC1B,MAAMrE,EAAUkE,MAAM1F,KAAK+F,EAAM,GAAG,IAC9BC,EAAiBN,MAAM1F,KAAK6H,EAAKH,+BAA+B1D,QAAOC,IAAQ8B,EAAME,MAAKC,IAAA,IAAEC,GAAKD,EAAA,OAAKC,IAASlC,CAAG,MACxH,IAAK,MAAMlE,KAAUyB,EACnBoB,EAAQhD,QAAQwG,EAAqCJ,EAAgBjG,GAEzE,CACF,CACF,CAEA,OAAO6C,CACT,CAEQkD,UAAAA,CAAWL,EAAoEG,GACrF,MAAMC,EAAkD,GAClDQ,EAAwDlI,KAAKmI,gBAAgBb,EAA6BG,GAEhH,IAAK,MAAMW,KAAeF,EAAc,CACtC,MAAOG,EAAUC,GAAgBF,EAAY,GACzCE,EAAaC,OAASd,GAAaW,EAAYI,OAAMC,IAAA,IAAE,CAAEpF,GAAQoF,EAAA,OAAKzI,KAAK0I,aAAarF,EAASiF,EAAa,KAChHZ,EAAOjG,KAAK2G,EAEhB,CAEA,OAAOV,CACT,CAEQS,eAAAA,CAAgBb,EAAoEG,GAC1F,GAAIA,EAAYH,EAA4BvD,OAAQ,MAAO,GAC3D,GAAkB,IAAd0D,EAAiB,OAAOH,EAA4BnB,KAAIwC,GAAQ,CAACA,KAErE,MAAMT,EAAwD,GAQ9D,OAPAZ,EAA4B9H,SAAQ,CAACmJ,EAA2CC,KAClD5I,KAAKmI,gBAAgBb,EAA4BuB,MAAMD,EAAQ,GAAInB,EAAY,GACvFjI,SAAQsJ,IAC1BZ,EAAazG,KAAK,CAACkH,KAASG,GAAoB,GAChD,IAGGZ,CACT,CAEQQ,YAAAA,CAAaK,EAAgBC,GACnC,GAAID,EAAKR,OAASS,EAAKT,KAAM,OAAO,EACpC,IAAK,MAAMU,KAAKF,EAAM,IAAKC,EAAKE,IAAID,GAAI,OAAO,EAC/C,OAAO,CACT,EAGF,SAAShB,EACPkB,EACAvH,GAEA,OAAOuH,EAAUhD,KACdL,GACC,IAAInE,EACFmE,EACAlE,EACA4H,EAAsC/G,OAG9C,CCnGA,IAAImH,EAAoB,ICeT,MAMb7J,WAAAA,GAAe,KALP8J,6BAAuB,OACvBC,wBAAkB,OAClBC,mBAAa,OACbC,iBAAW,EAGjBhK,KAAK6J,wBAA0B,CAC7B,IAAI1H,EACJ,IAAIK,EACJ,IAAII,EACJ,IAAIC,GAGN7C,KAAK8J,mBAAqB,CACxB,IAAI7G,EACJ,IAAIiB,EACJ,IAAIK,EACJ,IAAIO,GAGN9E,KAAK+J,cAAgB,CACnB,IAAIvD,EACJ,IAAII,EACJ,IAAIE,EACJ,IAAI0C,GAGNxJ,KAAKgK,YAAc,IAAIzE,CACzB,CAEA0E,iBAAAA,CACE3H,EACA4H,GAEA,IAAIC,EAAenK,KAAKgK,YAAYvE,kBAAkB,CAACnD,IACvD,EAAG,CACD,IAAI8H,EAAyC,GAC7C,IAAK,MAAMC,KAAQrK,KAAK6J,wBACtB,IAAK,MAAMS,KAAeH,EACxBC,EAAqBA,EAAmBG,OACtCF,EAAKhI,YAAYiI,IAKvB,IAAIE,EAAgD,GACpD,EAAG,CACDA,EAA4B,GAC5B,IAAK,MAAMH,KAAQrK,KAAK+J,cACtB,IAAK,MAAMtG,KAAU2G,EACnBI,EAA4BA,EAA0BD,OACpDF,EAAKhI,YAAY+H,IAIvBA,EAAqBA,EAAmBG,OACtCC,EAEJ,OAASA,EAA0BzG,OAAS,GAE5CqG,EAAmB5K,SAASsE,IAC1BoG,EAAYpG,EAAG,IAGjBqG,EAAe,GACf,IAAK,MAAME,KAAQrK,KAAK8J,mBACtBK,EAAeA,EAAaI,OAC1BF,EAAKhI,YAAY+H,IAGrBD,EAAenK,KAAKgK,YAAYvE,kBAAkB0E,GAClDA,EAAa3K,SAAS2K,IACpBD,EAAYC,EAAa,GAE7B,OAASA,EAAapG,OAAS,EACjC,GDxFF0G,iBAAiB,WAAW,EAAGC,WAC7BC,QAAQC,IAAI,qBAAsBF,GAElC,IAAIG,EAAc,IAAI9H,EACpB3D,EAAeO,GAAG+K,EAAKI,MAAM,GAAIJ,EAAKI,MAAM,IAC5CJ,EAAKK,MACL,QAEFnB,EAAkBK,kBAAkBY,EAAaX,YAAY,G","sources":["sudoku/SudokuPosition.ts","sudoku/SudokuBox.ts","sudoku/SudokuEventType.ts","sudoku/CantBeFoundEvent.ts","finder/numberFound2cantBe/BoxCantBeRule.ts","finder/numberFound2cantBe/HorizontalCantBeRule.ts","finder/numberFound2cantBe/VerticalCantBeRule.ts","finder/numberFound2cantBe/OnePositionCantBeRule.ts","sudoku/NumberFoundEvent.ts","finder/cantBe2NumberFound/OnlyOnePlaceHorizontalLine.ts","finder/cantBe2NumberFound/OnlyOnePlaceVerticalLine.ts","finder/cantBe2NumberFound/OnlyOnePlaceBox.ts","finder/cantBe2NumberFound/OnePositionFinder.ts","sudoku/EventFilter.ts","finder/cantBe2cantBe/Utils.ts","finder/cantBe2cantBe/PairBasedExcluderInVerticalLine.ts","finder/cantBe2cantBe/PairBasedExcluderInHorizontalLine.ts","finder/cantBe2cantBe/SubGroupBasedExcluderInBox.ts","sudoku/SudokuHorizontalLine.ts","sudoku/SudokuYCoordinate.ts","finder/cantBe2cantBe/SubGroupBasedExcluderInHorizontalLine.ts","sudoku.worker.js","sudoku/RuleOrchestration.ts"],"sourcesContent":["import SudokuXCoordinate from \"./SudokuXCoordinate\";\nimport SudokuYCoordinate from \"./SudokuYCoordinate\";\n\nexport default class SudokuPosition {\n  readonly xCoordinate: SudokuXCoordinate;\n  readonly yCoordinate: SudokuYCoordinate;\n\n  private static allInstances: SudokuPosition[][] = SudokuPosition.createAll();\n\n  private static createAll() {\n    const allXCoordinates: SudokuXCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n    const allYCoordinates: SudokuYCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n    const all: SudokuPosition[][] = [[], [], [], [], [], [], [], [], []];\n    allXCoordinates.forEach((x) => {\n      allYCoordinates.forEach((y) => {\n        all[x][y] = new SudokuPosition(x, y);\n      });\n    });\n    return all;\n  }\n\n  public static of(\n    xCoordinate: SudokuXCoordinate,\n    yCoordinate: SudokuYCoordinate,\n  ): SudokuPosition {\n    return SudokuPosition.allInstances[xCoordinate][yCoordinate];\n  }\n\n  private constructor(\n    xCoordinate: SudokuXCoordinate,\n    yCoordinate: SudokuYCoordinate,\n  ) {\n    this.xCoordinate = xCoordinate;\n    this.yCoordinate = yCoordinate;\n  }\n\n  getXCoordinate() {\n    return this.xCoordinate;\n  }\n\n  getYCoordinate() {\n    return this.yCoordinate;\n  }\n\n  toString() {\n    return \"Pos: [\" + this.xCoordinate + \",\" + this.yCoordinate + \"]\";\n  }\n\n  valueOf() {\n    return \"[\" + this.xCoordinate + \"][\" + this.yCoordinate + \"]\";\n  }\n}\n","import SudokuPosition from \"./SudokuPosition\";\nimport SudokuYCoordinate from \"./SudokuYCoordinate\";\nimport SudokuXCoordinate from \"./SudokuXCoordinate\";\n\ntype BoxCoordinate = 0 | 1 | 2;\n\nexport default class SudokuBox {\n  private readonly x: BoxCoordinate;\n  private readonly y: BoxCoordinate;\n\n  private static allInstances: SudokuBox[][] = SudokuBox.createAll();\n\n  private constructor(x: BoxCoordinate, y: BoxCoordinate) {\n    if (x < 0 || y < 0 || x > 2 || y > 2) {\n      throw new Error(\"illegal argument x:\" + x + \" y: \" + y);\n    }\n    this.x = x;\n    this.y = y;\n  }\n\n  getX() {\n    return this.x;\n  }\n\n  getY() {\n    return this.y;\n  }\n\n  static getAll(): SudokuBox[] {\n    return this.allInstances.flat();\n  }\n\n  private static createAll() {\n    const allBoxCoordinates: BoxCoordinate[] = [0, 1, 2];\n    const all: SudokuBox[][] = [[], [], []];\n    allBoxCoordinates.forEach((x) => {\n      allBoxCoordinates.forEach((y) => {\n        all[x][y] = new SudokuBox(x, y);\n      });\n    });\n    return all;\n  }\n\n  static createByPosition(postion: SudokuPosition) {\n    const x = postion.getXCoordinate();\n    const y = postion.getYCoordinate();\n    const boxXCoordinate = this.boxCoordinateFor(x);\n    const boxYCoordinate = this.boxCoordinateFor(y);\n    return this.allInstances[boxXCoordinate][boxYCoordinate];\n  }\n\n  private static boxCoordinateFor(\n    coordinate: SudokuXCoordinate | SudokuYCoordinate,\n  ) {\n    if (coordinate === 0 || coordinate === 1 || coordinate === 2) {\n      return 0;\n    } else if (coordinate === 3 || coordinate === 4 || coordinate === 5) {\n      return 1;\n    } else {\n      return 2;\n    }\n  }\n\n  private static sudokuCoordinateFor(\n    coordinate: BoxCoordinate,\n  ): Array<SudokuXCoordinate | SudokuYCoordinate> {\n    if (coordinate === 0) {\n      return [0, 1, 2];\n    } else if (coordinate === 1) {\n      return [3, 4, 5];\n    } else {\n      return [6, 7, 8];\n    }\n  }\n\n  static create(x: number, y: number) {\n    return this.allInstances[x][y];\n  }\n\n  allSudokuPositionInThisBox() {\n    let result: SudokuPosition[] = [];\n    SudokuBox.sudokuCoordinateFor(this.y).forEach((yC) => {\n      SudokuBox.sudokuCoordinateFor(this.x).forEach((xC) => {\n        const position = SudokuPosition.of(xC, yC);\n        result.push(position);\n      });\n    });\n    return result;\n  }\n\n  toString() {\n    return \"Box: [\" + this.x + \",\" + this.y + \"]\";\n  }\n}\n","enum SudokuEventType {\n  CANT_BE,\n  NUMBER_FOUND,\n}\nexport default SudokuEventType;\n","import SudokuPosition from \"./SudokuPosition\";\nimport SudokuEventType from \"./SudokuEventType\";\nimport SudokuNumber from \"./SudokuNumber\";\n\nexport default class CantBeFoundEvent {\n  readonly type: SudokuEventType = SudokuEventType.CANT_BE;\n  readonly position: SudokuPosition;\n  readonly number: SudokuNumber;\n  readonly from: string;\n\n  constructor(postion: SudokuPosition, number: SudokuNumber, from: string) {\n    this.position = postion;\n    this.number = number;\n    this.from = from;\n  }\n\n  getNumber() {\n    return this.number;\n  }\n\n  getPosition() {\n    return this.position;\n  }\n\n  getFrom() {\n    return this.from;\n  }\n}\n","import SudokuBox from \"../../sudoku/SudokuBox\";\nimport CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport NumberFound2CantBe from \"./NumberFound2CantBe\";\n\nexport default class BoxCantBeRule implements NumberFound2CantBe {\n  private readonly ruleName = \"BoxCantBeRule\";\n\n  finderLogic(numberFoundEvent: NumberFoundEvent) {\n    const result = [];\n    const box = SudokuBox.createByPosition(numberFoundEvent.getPosition());\n\n    for (let position of box.allSudokuPositionInThisBox()) {\n      if (\n        position.getYCoordinate() !==\n          numberFoundEvent.getPosition().getYCoordinate() ||\n        position.getXCoordinate() !==\n          numberFoundEvent.getPosition().getXCoordinate()\n      ) {\n        result.push(\n          new CantBeFoundEvent(\n            position,\n            numberFoundEvent.getNumber(),\n            this.ruleName,\n          ),\n        );\n      }\n    }\n\n    return result;\n  }\n}\n","import CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport NumberFound2CantBe from \"./NumberFound2CantBe\";\nimport SudokuYCoordinate from \"../../sudoku/SudokuYCoordinate\";\n\nexport default class HorizontalCantBeRule implements NumberFound2CantBe {\n  private readonly name = \"HorizontalCantBeRule\";\n\n  finderLogic(numberFoundEvent: NumberFoundEvent) {\n    const result: CantBeFoundEvent[] = [];\n    const yCoordinates: SudokuYCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n\n    let xk = numberFoundEvent.getPosition().getXCoordinate();\n    yCoordinates.forEach((yk) => {\n      if (yk !== numberFoundEvent.getPosition().getYCoordinate()) {\n        result.push(\n          new CantBeFoundEvent(\n            SudokuPosition.of(xk, yk),\n            numberFoundEvent.getNumber(),\n            this.name,\n          ),\n        );\n      }\n    });\n\n    return result;\n  }\n}\n","import CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport NumberFound2CantBe from \"./NumberFound2CantBe\";\nimport SudokuXCoordinate from \"../../sudoku/SudokuXCoordinate\";\n\nexport default class VerticalCantBeRule implements NumberFound2CantBe {\n  private readonly name = \"VerticalCantBeRule\";\n\n  finderLogic(numberFoundEvent: NumberFoundEvent) {\n    const result: CantBeFoundEvent[] = [];\n    const xCoordinates: SudokuXCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n\n    let yk = numberFoundEvent.getPosition().getYCoordinate();\n    xCoordinates.forEach((xk) => {\n      if (xk !== numberFoundEvent.getPosition().getXCoordinate()) {\n        result.push(\n          new CantBeFoundEvent(\n            SudokuPosition.of(xk, yk),\n            numberFoundEvent.getNumber(),\n            this.name,\n          ),\n        );\n      }\n    });\n    return result;\n  }\n}\n","import CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport NumberFound2CantBe from \"./NumberFound2CantBe\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\n\nexport default class OnePositionCantBeRule implements NumberFound2CantBe {\n  private readonly name = \"OnePositionCantBeRule\";\n\n  finderLogic(numberFoundEvent: NumberFoundEvent) {\n    const result: CantBeFoundEvent[] = [];\n    const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    numbers.forEach((i) => {\n      if (i !== numberFoundEvent.getNumber()) {\n        result.push(\n          new CantBeFoundEvent(numberFoundEvent.getPosition(), i, this.name),\n        );\n      }\n    });\n    return result;\n  }\n}\n","import SudokuPosition from \"./SudokuPosition\";\nimport SudokuEventType from \"./SudokuEventType\";\nimport SudokuNumber from \"./SudokuNumber\";\n\nexport default class NumberFoundEvent {\n  readonly type = SudokuEventType.NUMBER_FOUND;\n  readonly position: SudokuPosition;\n  readonly number: SudokuNumber;\n  readonly from: string;\n\n  constructor(position: SudokuPosition, number: SudokuNumber, from: string) {\n    this.position = position;\n    this.number = number;\n    this.from = from;\n  }\n\n  getNumber() {\n    return this.number;\n  }\n\n  getPosition() {\n    return this.position;\n  }\n\n  getFrom() {\n    return this.from;\n  }\n}\n","import SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport CantBe2NumberFound from \"./CantBe2NumberFound\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\nimport SudokuYCoordinate from \"../../sudoku/SudokuYCoordinate\";\n\nexport default class OnlyOnePlaceHorizontalLine implements CantBe2NumberFound {\n  /**\n   * Es wird für jede Zeile(0-8) für jede Zahl(1-9) gespeichert, wo sie nicht hin darf.\n   */\n  private readonly memory: Map<\n    number,\n    Map<SudokuNumber, Array<SudokuPosition>>\n  >;\n  private readonly name = \"OnlyOnePlaceHorizontalLine\";\n\n  constructor() {\n    this.memory = OnlyOnePlaceHorizontalLine.initMemory();\n  }\n\n  private static initMemory() {\n    const memory = new Map<number, Map<SudokuNumber, Array<SudokuPosition>>>();\n    const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\n    for (let x: number = 0; x < 9; x++) {\n      let map1 = new Map<SudokuNumber, Array<SudokuPosition>>();\n      numbers.forEach((i) => {\n        map1.set(i, []);\n      });\n      memory.set(x, map1);\n    }\n    return memory;\n  }\n\n  finderLogic(cantBes: Array<CantBeFoundEvent>): Array<NumberFoundEvent> {\n    const result: Array<NumberFoundEvent> = [];\n    cantBes.forEach((cantBe) => {\n      const canBeForNumberInLine =\n        this.memory\n          .get(cantBe.getPosition().getXCoordinate())\n          ?.get(cantBe.getNumber()) || []; // TODO handle undefine\n      if (\n        !canBeForNumberInLine.find(\n          (it) =>\n            it.getXCoordinate() === cantBe.getPosition().getXCoordinate() &&\n            it.getYCoordinate() === cantBe.getPosition().getYCoordinate(),\n        )\n      ) {\n        canBeForNumberInLine.push(cantBe.getPosition());\n        if (canBeForNumberInLine.length === 8) {\n          result.push(\n            new NumberFoundEvent(\n              OnlyOnePlaceHorizontalLine.onlyPossiblePosition(\n                canBeForNumberInLine,\n              ),\n              cantBe.getNumber(),\n              this.name,\n            ),\n          );\n        }\n      }\n    });\n    return result;\n  }\n\n  private static onlyPossiblePosition(\n    canBeForNumberInLine: SudokuPosition[],\n  ): SudokuPosition {\n    const yCoordinates: SudokuYCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n    for (let i = 0; i < yCoordinates.length; i++) {\n      let yCoordinate = yCoordinates[i];\n      if (\n        !canBeForNumberInLine.find((it) => it.getYCoordinate() === yCoordinate)\n      ) {\n        return SudokuPosition.of(\n          canBeForNumberInLine[0].getXCoordinate(),\n          yCoordinate,\n        );\n      }\n    }\n    throw new Error(\"should not happen\");\n  }\n}\n","import SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport CantBe2NumberFound from \"./CantBe2NumberFound\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\nimport SudokuXCoordinate from \"../../sudoku/SudokuXCoordinate\";\nimport SudokuYCoordinate from \"../../sudoku/SudokuYCoordinate\";\n\nexport default class OnlyOnePlaceVerticalLine implements CantBe2NumberFound {\n  /**\n   * Es wird für jede Reihe(0-8) für jede Zahl(1-9) gespeichert, wo sie nicht hin darf.\n   */\n  private readonly memory: Map<\n    SudokuYCoordinate,\n    Map<SudokuNumber, Array<SudokuPosition>>\n  >;\n  private readonly name = \"OnlyOnePlaceVerticalLine\";\n\n  constructor() {\n    this.memory = OnlyOnePlaceVerticalLine.initMemory();\n  }\n\n  static initMemory() {\n    const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    const sudokuYCoordinates: SudokuYCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n\n    const memory = new Map<\n      SudokuYCoordinate,\n      Map<SudokuNumber, Array<SudokuPosition>>\n    >();\n    sudokuYCoordinates.forEach((x) => {\n      let map1 = new Map<SudokuNumber, Array<SudokuPosition>>();\n      numbers.forEach((i) => {\n        map1.set(i, []);\n      });\n      memory.set(x, map1);\n    });\n    return memory;\n  }\n\n  finderLogic(cantBes: Array<CantBeFoundEvent>): Array<NumberFoundEvent> {\n    const result: Array<NumberFoundEvent> = [];\n    cantBes.forEach((cantBe) => {\n      const canBeForNumberInLine =\n        this.memory\n          .get(cantBe.getPosition().getYCoordinate())\n          ?.get(cantBe.getNumber()) || []; // TODO handle undefined\n      if (\n        !canBeForNumberInLine.find(\n          (it) =>\n            it.getXCoordinate() === cantBe.getPosition().getXCoordinate() &&\n            it.getYCoordinate() === cantBe.getPosition().getYCoordinate(),\n        )\n      ) {\n        canBeForNumberInLine.push(cantBe.getPosition());\n        if (canBeForNumberInLine.length === 8) {\n          result.push(\n            new NumberFoundEvent(\n              OnlyOnePlaceVerticalLine.onlyPossiblePosition(\n                canBeForNumberInLine,\n              ),\n              cantBe.getNumber(),\n              this.name,\n            ),\n          );\n        }\n      }\n    });\n    return result;\n  }\n\n  private static onlyPossiblePosition(\n    canBeForNumberInLine: SudokuPosition[],\n  ): SudokuPosition {\n    const xCoordinates: SudokuXCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n    for (let i = 0; i < xCoordinates.length; i++) {\n      let xCoordinate = xCoordinates[i];\n      if (\n        !canBeForNumberInLine.find((it) => it.getXCoordinate() === xCoordinate)\n      ) {\n        return SudokuPosition.of(\n          xCoordinate,\n          canBeForNumberInLine[0].getYCoordinate(),\n        );\n      }\n    }\n    throw new Error(\"should not happen\");\n  }\n}\n","import SudokuBox from \"../../sudoku/SudokuBox\";\nimport SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport CantBe2NumberFound from \"./CantBe2NumberFound\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\n\nfunction samePosition(one: SudokuPosition, two: SudokuPosition) {\n  return (\n    one.getXCoordinate() === two.getXCoordinate() &&\n    one.getYCoordinate() === two.getYCoordinate()\n  );\n}\n\nexport default class OnlyOnePlaceBox implements CantBe2NumberFound {\n  /**\n   * Es wird für jede Box für jede Zahl(1-9) gespeichert, wo sie nicht hin darf.\n   */\n  private readonly memory: Map<\n    SudokuBox,\n    Map<SudokuNumber, Array<SudokuPosition>>\n  > = OnlyOnePlaceBox.init();\n  private readonly name = \"OnlyOnePlaceBox\";\n\n  private static init() {\n    const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    const memory = new Map<\n      SudokuBox,\n      Map<SudokuNumber, Array<SudokuPosition>>\n    >();\n    for (let x = 0; x < 3; x++) {\n      for (let y = 0; y < 3; y++) {\n        let map1 = new Map<SudokuNumber, Array<SudokuPosition>>();\n        numbers.forEach((i) => {\n          map1.set(i, []);\n        });\n        memory.set(SudokuBox.create(x, y), map1);\n      }\n    }\n    return memory;\n  }\n\n  finderLogic(cantBes: Array<CantBeFoundEvent>) {\n    const results: NumberFoundEvent[] = [];\n    for (let info of cantBes) {\n      let position = info.getPosition();\n      let nTNumber = info.getNumber();\n      let box: SudokuBox = SudokuBox.createByPosition(position);\n\n      const notHeres = this.memory.get(box)?.get(nTNumber);\n      if (notHeres && !notHeres.find((it) => samePosition(position, it))) {\n        notHeres.push(position);\n        if (notHeres.length === 8) {\n          box.allSudokuPositionInThisBox().forEach((newPos) => {\n            if (!notHeres.find((it) => samePosition(newPos, it))) {\n              results.push(new NumberFoundEvent(newPos, nTNumber, this.name)); //FIXME\n            }\n          });\n        }\n      }\n    }\n    return results;\n  }\n}\n","import CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport CantBe2NumberFound from \"./CantBe2NumberFound\";\nimport NumberFoundEvent from \"../../sudoku/NumberFoundEvent\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\n\nexport default class OnePositionFinder implements CantBe2NumberFound {\n  private readonly notThisNumber: boolean[][][] =\n    OnePositionFinder.createBoolean3dArray();\n  private readonly name = \"OnePositionFinder\";\n\n  finderLogic(cantBes: CantBeFoundEvent[]) {\n    const results: NumberFoundEvent[] = [];\n    for (let event of cantBes) {\n      const position = event.getPosition();\n      const nTNumber = event.getNumber();\n      this.notThisNumber[position.getXCoordinate()][position.getYCoordinate()][\n        nTNumber\n      ] = true;\n\n      let anzFalse = 0;\n      let lastFalsePosition: SudokuNumber | null = null;\n      const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n\n      numbers.forEach((i) => {\n        if (\n          !this.notThisNumber[position.getXCoordinate()][\n            position.getYCoordinate()\n          ][i]\n        ) {\n          anzFalse++;\n          lastFalsePosition = i;\n        }\n      });\n      if (anzFalse === 1 && lastFalsePosition !== null) {\n        results.push(\n          new NumberFoundEvent(position, lastFalsePosition, this.name),\n        );\n      }\n    }\n    return results;\n  }\n\n  private static createBoolean3dArray() {\n    const array3d: boolean[][][] = [];\n\n    for (let i = 0; i < 9; i++) {\n      array3d[i] = [];\n      for (let j = 0; j < 9; j++) {\n        array3d[i][j] = [];\n        for (let k = 0; k < 9; k++) {\n          array3d[i][j][k] = false;\n        }\n      }\n    }\n\n    return array3d;\n  }\n}\n","import SudokuEventType from \"./SudokuEventType\";\nimport NumberFoundEvent from \"./NumberFoundEvent\";\n\nexport default class EventFilter {\n  private numberFound: number[][] = [[], [], [], [], [], [], [], [], []];\n\n  removeAlreadySeen(toFilter: NumberFoundEvent[]) {\n    const filtered = [];\n\n    for (const numberFoundEvent of toFilter) {\n      if (numberFoundEvent.type === SudokuEventType.NUMBER_FOUND) {\n        if (\n          !this.numberFound[numberFoundEvent.getPosition().getXCoordinate()][\n            numberFoundEvent.getPosition().getYCoordinate()\n          ]\n        ) {\n          this.numberFound[numberFoundEvent.getPosition().getXCoordinate()][\n            numberFoundEvent.getPosition().getYCoordinate()\n          ] = numberFoundEvent.getNumber();\n          filtered.push(numberFoundEvent);\n        }\n        // TODO validate number in case of alerdy seen\n      } else {\n        // filter CANT BES\n        filtered.push(numberFoundEvent);\n      }\n    }\n    return filtered;\n  }\n}\n","import SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport SudokuBox from \"../../sudoku/SudokuBox\";\nimport SudokuYCoordinate from \"../../sudoku/SudokuYCoordinate\";\nimport SudokuXCoordinate from \"../../sudoku/SudokuXCoordinate\";\n\nexport function getAllPossiblePositions(\n  notHeres: SudokuPosition[],\n  box: SudokuBox,\n): SudokuPosition[] {\n  return box\n    .allSudokuPositionInThisBox()\n    .filter((pos) => notHeres.indexOf(pos) < 0);\n}\n\nexport function getYCoordinatesOf(\n  possiblePositions: SudokuPosition[],\n): SudokuYCoordinate[] {\n  return distinct(possiblePositions.map((pos) => pos.getYCoordinate()));\n}\n\nexport function getXCoordinatesOf(\n  possiblePositions: SudokuPosition[],\n): SudokuXCoordinate[] {\n  return distinct(possiblePositions.map((pos) => pos.getXCoordinate()));\n}\n\nfunction distinct<T>(list: T[]): T[] {\n  return list.filter((e, i, self) => i === self.indexOf(e));\n}\n","import SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\nimport SudokuXCoordinate from \"../../sudoku/SudokuXCoordinate\";\nimport SudokuYCoordinate from \"../../sudoku/SudokuYCoordinate\";\nimport SudokuBox from \"../../sudoku/SudokuBox\";\nimport CantBe2CantBe from \"./CantBe2CantBe\";\nimport { getAllPossiblePositions, getYCoordinatesOf } from \"./Utils\";\n\nfunction samePosition(one: SudokuPosition, two: SudokuPosition) {\n  return (\n    one.getXCoordinate() === two.getXCoordinate() &&\n    one.getYCoordinate() === two.getYCoordinate()\n  );\n}\n\nexport default class PairBasedExcluderInVerticalLine implements CantBe2CantBe {\n  /**\n   * Es wird für jede Box für jede Zahl(1-9) gespeichert, wo sie nicht hin darf.\n   */\n  private readonly memory: Map<\n    SudokuBox,\n    Map<SudokuNumber, Array<SudokuPosition>>\n  > = PairBasedExcluderInVerticalLine.init();\n  private readonly name = \"PairBasedExcluderInVerticalLine\";\n\n  private static init() {\n    const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    const memory = new Map<\n      SudokuBox,\n      Map<SudokuNumber, Array<SudokuPosition>>\n    >();\n    for (let x = 0; x < 3; x++) {\n      for (let y = 0; y < 3; y++) {\n        let map1 = new Map<SudokuNumber, Array<SudokuPosition>>();\n        numbers.forEach((i) => {\n          map1.set(i, []);\n        });\n        memory.set(SudokuBox.create(x, y), map1);\n      }\n    }\n    return memory;\n  }\n\n  finderLogic(cantBes: Array<CantBeFoundEvent>): CantBeFoundEvent[] {\n    const results: CantBeFoundEvent[] = [];\n    for (let info of cantBes) {\n      let position = info.getPosition();\n      let nTNumber = info.getNumber();\n      let box: SudokuBox = SudokuBox.createByPosition(position);\n\n      const notHeres = this.memory.get(box)?.get(nTNumber);\n      if (notHeres && !notHeres.find((it) => samePosition(position, it))) {\n        notHeres.push(position);\n        if (notHeres.length >= 6 && notHeres.length <= 7) {\n          const possiblePositions: SudokuPosition[] = getAllPossiblePositions(\n            notHeres,\n            box,\n          );\n          const yCoordinatesOfPossiblePositions: SudokuYCoordinate[] =\n            getYCoordinatesOf(possiblePositions);\n          if (yCoordinatesOfPossiblePositions.length === 1) {\n            // TADA gefunden\n            const newCantBeFoundEvent: CantBeFoundEvent[] =\n              generateCantBeFoundEventFor(\n                yCoordinatesOfPossiblePositions[0],\n                nTNumber,\n                box,\n              );\n            results.push(...newCantBeFoundEvent);\n          }\n        }\n      }\n    }\n    return results;\n  }\n}\n\nfunction generateCantBeFoundEventFor(\n  yCoordinatesOfPossiblePositions: SudokuYCoordinate,\n  nTNumber: SudokuNumber,\n  box: SudokuBox,\n): CantBeFoundEvent[] {\n  const allXCoords: SudokuXCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n  return allXCoords\n    .map((xCoordinate) =>\n      SudokuPosition.of(xCoordinate, yCoordinatesOfPossiblePositions),\n    )\n    .filter((pos) => box.allSudokuPositionInThisBox().indexOf(pos) < 0)\n    .map(\n      (pos) =>\n        new CantBeFoundEvent(\n          pos,\n          nTNumber,\n          PairBasedExcluderInVerticalLine.name,\n        ),\n    );\n}\n","import SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\nimport SudokuXCoordinate from \"../../sudoku/SudokuXCoordinate\";\nimport SudokuYCoordinate from \"../../sudoku/SudokuYCoordinate\";\nimport SudokuBox from \"../../sudoku/SudokuBox\";\nimport CantBe2CantBe from \"./CantBe2CantBe\";\nimport { getAllPossiblePositions, getXCoordinatesOf } from \"./Utils\";\n\nfunction samePosition(one: SudokuPosition, two: SudokuPosition) {\n  return (\n    one.getXCoordinate() === two.getXCoordinate() &&\n    one.getYCoordinate() === two.getYCoordinate()\n  );\n}\n\nexport default class PairBasedExcluderInHorizontalLine\n  implements CantBe2CantBe\n{\n  /**\n   * Es wird für jede Box für jede Zahl(1-9) gespeichert, wo sie nicht hin darf.\n   */\n  private readonly memory: Map<\n    SudokuBox,\n    Map<SudokuNumber, Array<SudokuPosition>>\n  > = PairBasedExcluderInHorizontalLine.init();\n  private readonly name = \"PairBasedExcluderInHorizontalLine\";\n\n  private static init() {\n    const numbers: SudokuNumber[] = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    const memory = new Map<\n      SudokuBox,\n      Map<SudokuNumber, Array<SudokuPosition>>\n    >();\n    for (let x = 0; x < 3; x++) {\n      for (let y = 0; y < 3; y++) {\n        let map1 = new Map<SudokuNumber, Array<SudokuPosition>>();\n        numbers.forEach((i) => {\n          map1.set(i, []);\n        });\n        memory.set(SudokuBox.create(x, y), map1);\n      }\n    }\n    return memory;\n  }\n\n  finderLogic(cantBes: Array<CantBeFoundEvent>): CantBeFoundEvent[] {\n    const results: CantBeFoundEvent[] = [];\n    for (let info of cantBes) {\n      let position = info.getPosition();\n      let nTNumber = info.getNumber();\n      let box: SudokuBox = SudokuBox.createByPosition(position);\n\n      const notHeres = this.memory.get(box)?.get(nTNumber);\n      if (notHeres && !notHeres.find((it) => samePosition(position, it))) {\n        notHeres.push(position);\n        if (notHeres.length >= 6 && notHeres.length <= 7) {\n          const possiblePositions: SudokuPosition[] = getAllPossiblePositions(\n            notHeres,\n            box,\n          );\n          const xCoordinatesOfPossiblePositions: SudokuXCoordinate[] =\n            getXCoordinatesOf(possiblePositions);\n          if (xCoordinatesOfPossiblePositions.length === 1) {\n            // TADA gefunden\n            const newCantBeFoundEvent: CantBeFoundEvent[] =\n              generateCantBeFoundEventFor(\n                xCoordinatesOfPossiblePositions[0],\n                nTNumber,\n                box,\n              );\n            results.push(...newCantBeFoundEvent);\n          }\n        }\n      }\n    }\n    return results;\n  }\n}\n\nfunction generateCantBeFoundEventFor(\n  xCoordinatesOfPossiblePositions: SudokuXCoordinate,\n  nTNumber: SudokuNumber,\n  box: SudokuBox,\n): CantBeFoundEvent[] {\n  const allYCoords: SudokuYCoordinate[] = [0, 1, 2, 3, 4, 5, 6, 7, 8];\n  return allYCoords\n    .map((yCoordinate) =>\n      SudokuPosition.of(xCoordinatesOfPossiblePositions, yCoordinate),\n    )\n    .filter((pos) => box.allSudokuPositionInThisBox().indexOf(pos) < 0)\n    .map(\n      (pos) =>\n        new CantBeFoundEvent(\n          pos,\n          nTNumber,\n          PairBasedExcluderInHorizontalLine.name,\n        ),\n    );\n}\n","import CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport CantBe2CantBe from \"./CantBe2CantBe\";\nimport SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport SudokuBox from \"../../sudoku/SudokuBox\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\n\nexport default class SubGroupBasedExcluderInBox implements CantBe2CantBe {\n  private readonly boxToPositionsToPossibleNumbers: Map<SudokuBox, Map<SudokuPosition, Set<SudokuNumber>>>;\n\n  constructor() {\n    this.boxToPositionsToPossibleNumbers = new Map();\n    for (const box of SudokuBox.getAll()) {\n      const positionToPossibleNumbers = new Map<SudokuPosition, Set<SudokuNumber>>();\n      for (const position of box.allSudokuPositionInThisBox()) {\n        positionToPossibleNumbers.set(position, new Set([1, 2, 3, 4, 5, 6, 7, 8, 9]));\n      }\n      this.boxToPositionsToPossibleNumbers.set(box, positionToPossibleNumbers);\n    }\n  }\n\n  finderLogic(cantBes: Array<CantBeFoundEvent>): CantBeFoundEvent[] {\n    const results: CantBeFoundEvent[] = [];\n    const affectedBoxes: Set<SudokuBox> = new Set();\n\n    // Update boxToPositionsToPossibleNumbers with new cantBes and track affected boxes\n    for (const cantBe of cantBes) {\n      const box = SudokuBox.createByPosition(cantBe.getPosition());\n      const position = cantBe.getPosition();\n      const number = cantBe.getNumber();\n      const positionsToPossibleNumber = this.boxToPositionsToPossibleNumbers.get(box)!;\n      if (positionsToPossibleNumber.get(position)!.delete(number)) {\n        affectedBoxes.add(box);\n      }\n    }\n\n    // Find groups of positions with the same possible numbers within each affected box\n    for (const box of affectedBoxes) {\n      const positionsToPossibleNumber = this.boxToPositionsToPossibleNumbers.get(box)!;\n      const positionsWithPossibleNumber = Array.from(positionsToPossibleNumber.entries());\n\n      for (let groupSize = 2; groupSize <= 8; groupSize++) {\n        const groups: [SudokuPosition, Set<SudokuNumber>][][] = this.findGroups(positionsWithPossibleNumber, groupSize);\n        for (const group of groups) {\n          const numbers = Array.from(group[0][1]);\n          const otherPositions = Array.from(box.allSudokuPositionInThisBox()).filter(pos => !group.some(([gPos]) => gPos === pos));\n          for (const number of numbers) {\n            results.push(...generateCantBeFoundEventForPositions(otherPositions, number));\n          }\n        }\n      }\n    }\n\n    return results;\n  }\n\n  private findGroups(positionsWithPossibleNumber: [SudokuPosition, Set<SudokuNumber>][], groupSize: number): [SudokuPosition, Set<SudokuNumber>][][] {\n    const groups: [SudokuPosition, Set<SudokuNumber>][][] = [];\n    const combinations: [SudokuPosition, Set<SudokuNumber>][][] = this.getCombinations(positionsWithPossibleNumber, groupSize);\n\n    for (const combination of combinations) {\n      const [firstPos, firstNumbers] = combination[0];\n      if (firstNumbers.size === groupSize && combination.every(([, numbers]) => this.setsAreEqual(numbers, firstNumbers))) {\n        groups.push(combination);\n      }\n    }\n\n    return groups;\n  }\n\n  private getCombinations(positionsWithPossibleNumber: [SudokuPosition, Set<SudokuNumber>][], groupSize: number): [SudokuPosition, Set<SudokuNumber>][][] {\n    if (groupSize > positionsWithPossibleNumber.length) return [];\n    if (groupSize === 1) return positionsWithPossibleNumber.map(item => [item]);\n\n    const combinations: [SudokuPosition, Set<SudokuNumber>][][] = [];\n    positionsWithPossibleNumber.forEach((item: [SudokuPosition, Set<SudokuNumber>], index) => {\n      const smallerCombinations = this.getCombinations(positionsWithPossibleNumber.slice(index + 1), groupSize - 1);\n      smallerCombinations.forEach(smallerCombination => {\n        combinations.push([item, ...smallerCombination]);\n      });\n    });\n\n    return combinations;\n  }\n\n  private setsAreEqual(setA: Set<any>, setB: Set<any>): boolean {\n    if (setA.size !== setB.size) return false;\n    for (const a of setA) if (!setB.has(a)) return false;\n    return true;\n  }\n}\n\nfunction generateCantBeFoundEventForPositions(\n  positions: SudokuPosition[],\n  number: SudokuNumber,\n): CantBeFoundEvent[] {\n  return positions.map(\n    (pos) =>\n      new CantBeFoundEvent(\n        pos,\n        number,\n        SubGroupBasedExcluderInBox.name,\n      ),\n  );\n}\n","import SudokuPosition from \"./SudokuPosition\";\nimport SudokuXCoordinate from \"./SudokuXCoordinate\";\nimport {allSudokuYCoordinates} from \"./SudokuYCoordinate\";\n\nexport default class SudokuHorizontalLine {\n  private static allLines: SudokuHorizontalLine[] = [\n    new SudokuHorizontalLine(0),\n    new SudokuHorizontalLine(1),\n    new SudokuHorizontalLine(2),\n    new SudokuHorizontalLine(3),\n    new SudokuHorizontalLine(4),\n    new SudokuHorizontalLine(5),\n    new SudokuHorizontalLine(6),\n    new SudokuHorizontalLine(7),\n    new SudokuHorizontalLine(8),\n  ];\n  private readonly lineCoordinate: SudokuXCoordinate;\n\n  private constructor(lineCoordinate: SudokuXCoordinate) {\n    this.lineCoordinate = lineCoordinate;\n  }\n\n  static getAll(): SudokuHorizontalLine[] {\n    return SudokuHorizontalLine.allLines;\n  }\n\n  allSudokuPositionInThisLine(): SudokuPosition[] {\n    return allSudokuYCoordinates().map(y => SudokuPosition.of(this.lineCoordinate, y));\n  }\n\n  static createByPosition(position: SudokuPosition): SudokuHorizontalLine {\n    return SudokuHorizontalLine.allLines[position.getXCoordinate()]\n  }\n}\n","type SudokuYCoordinate = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\nexport default SudokuYCoordinate;\n\nexport function allSudokuYCoordinates(): SudokuYCoordinate[] {\n  return [0, 1, 2, 3, 4, 5, 6, 7, 8];\n}\n","import CantBeFoundEvent from \"../../sudoku/CantBeFoundEvent\";\nimport CantBe2CantBe from \"./CantBe2CantBe\";\nimport SudokuPosition from \"../../sudoku/SudokuPosition\";\nimport SudokuHorizontalLine from \"../../sudoku/SudokuHorizontalLine\";\nimport SudokuNumber from \"../../sudoku/SudokuNumber\";\n\nexport default class SubGroupBasedExcluderInHorizontalLine implements CantBe2CantBe {\n  private readonly lineToPositionsToPossibleNumbers: Map<SudokuHorizontalLine, Map<SudokuPosition, Set<SudokuNumber>>>;\n\n  constructor() {\n    this.lineToPositionsToPossibleNumbers = new Map();\n    for (const line of SudokuHorizontalLine.getAll()) {\n      const positionToPossibleNumbers = new Map<SudokuPosition, Set<SudokuNumber>>();\n      for (const position of line.allSudokuPositionInThisLine()) {\n        positionToPossibleNumbers.set(position, new Set([1, 2, 3, 4, 5, 6, 7, 8, 9]));\n      }\n      this.lineToPositionsToPossibleNumbers.set(line, positionToPossibleNumbers);\n    }\n  }\n\n  finderLogic(cantBes: Array<CantBeFoundEvent>): CantBeFoundEvent[] {\n    const results: CantBeFoundEvent[] = [];\n    const affectedLines: Set<SudokuHorizontalLine> = new Set();\n\n    // Update lineToPositionsToPossibleNumbers with new cantBes and track affected lines\n    for (const cantBe of cantBes) {\n      const line = SudokuHorizontalLine.createByPosition(cantBe.getPosition());\n      const position = cantBe.getPosition();\n      const number = cantBe.getNumber();\n      const positionsToPossibleNumber = this.lineToPositionsToPossibleNumbers.get(line)!;\n      if (positionsToPossibleNumber.get(position)!.delete(number)) {\n        affectedLines.add(line);\n      }\n    }\n\n    // Find groups of positions with the same possible numbers within each affected line\n    for (const line of affectedLines) {\n      const positionsToPossibleNumber = this.lineToPositionsToPossibleNumbers.get(line)!;\n      const positionsWithPossibleNumber = Array.from(positionsToPossibleNumber.entries());\n\n      for (let groupSize = 2; groupSize <= 8; groupSize++) {\n        const groups: [SudokuPosition, Set<SudokuNumber>][][] = this.findGroups(positionsWithPossibleNumber, groupSize);\n        for (const group of groups) {\n          const numbers = Array.from(group[0][1]);\n          const otherPositions = Array.from(line.allSudokuPositionInThisLine()).filter(pos => !group.some(([gPos]) => gPos === pos));\n          for (const number of numbers) {\n            results.push(...generateCantBeFoundEventForPositions(otherPositions, number));\n          }\n        }\n      }\n    }\n\n    return results;\n  }\n\n  private findGroups(positionsWithPossibleNumber: [SudokuPosition, Set<SudokuNumber>][], groupSize: number): [SudokuPosition, Set<SudokuNumber>][][] {\n    const groups: [SudokuPosition, Set<SudokuNumber>][][] = [];\n    const combinations: [SudokuPosition, Set<SudokuNumber>][][] = this.getCombinations(positionsWithPossibleNumber, groupSize);\n\n    for (const combination of combinations) {\n      const [firstPos, firstNumbers] = combination[0];\n      if (firstNumbers.size === groupSize && combination.every(([, numbers]) => this.setsAreEqual(numbers, firstNumbers))) {\n        groups.push(combination);\n      }\n    }\n\n    return groups;\n  }\n\n  private getCombinations(positionsWithPossibleNumber: [SudokuPosition, Set<SudokuNumber>][], groupSize: number): [SudokuPosition, Set<SudokuNumber>][][] {\n    if (groupSize > positionsWithPossibleNumber.length) return [];\n    if (groupSize === 1) return positionsWithPossibleNumber.map(item => [item]);\n\n    const combinations: [SudokuPosition, Set<SudokuNumber>][][] = [];\n    positionsWithPossibleNumber.forEach((item: [SudokuPosition, Set<SudokuNumber>], index) => {\n      const smallerCombinations = this.getCombinations(positionsWithPossibleNumber.slice(index + 1), groupSize - 1);\n      smallerCombinations.forEach(smallerCombination => {\n        combinations.push([item, ...smallerCombination]);\n      });\n    });\n\n    return combinations;\n  }\n\n  private setsAreEqual(setA: Set<any>, setB: Set<any>): boolean {\n    if (setA.size !== setB.size) return false;\n    for (const a of setA) if (!setB.has(a)) return false;\n    return true;\n  }\n}\n\nfunction generateCantBeFoundEventForPositions(\n  positions: SudokuPosition[],\n  number: SudokuNumber,\n): CantBeFoundEvent[] {\n  return positions.map(\n    (pos) =>\n      new CantBeFoundEvent(\n        pos,\n        number,\n        SubGroupBasedExcluderInHorizontalLine.name,\n      ),\n  );\n}\n","import SudokuPosition from \"./sudoku/SudokuPosition\";\nimport RuleOrchestration from \"./sudoku/RuleOrchestration\";\nimport NumberFoundEvent from \"./sudoku/NumberFoundEvent\";\n\nlet ruleOrchestration = new RuleOrchestration();\n\n// eslint-disable-next-line no-restricted-globals\naddEventListener(\"message\", ({ data }) => {\n  console.log(\"worker got message\", data);\n\n  let sudokuEvent = new NumberFoundEvent(\n    SudokuPosition.of(data.field[0], data.field[1]),\n    data.value,\n    \"USER\"\n  );\n  ruleOrchestration.handleGivenNumber(sudokuEvent, postMessage);\n});\n","import BoxCantBeRule from \"../finder/numberFound2cantBe/BoxCantBeRule\";\nimport HorizontalCantBeRule from \"../finder/numberFound2cantBe/HorizontalCantBeRule\";\nimport VerticalCantBeRule from \"../finder/numberFound2cantBe/VerticalCantBeRule\";\nimport OnePositionCantBeRule from \"../finder/numberFound2cantBe/OnePositionCantBeRule\";\nimport OnlyOnePlaceHorizontalLine from \"../finder/cantBe2NumberFound/OnlyOnePlaceHorizontalLine\";\nimport OnlyOnePlaceVerticalLine from \"../finder/cantBe2NumberFound/OnlyOnePlaceVerticalLine\";\nimport OnlyOnePlaceBox from \"../finder/cantBe2NumberFound/OnlyOnePlaceBox\";\nimport OnePositionFinder from \"../finder/cantBe2NumberFound/OnePositionFinder\";\nimport EventFilter from \"./EventFilter\";\nimport CantBeFoundEvent from \"./CantBeFoundEvent\";\nimport NumberFound2CantBe from \"../finder/numberFound2cantBe/NumberFound2CantBe\";\nimport NumberFoundEvent from \"./NumberFoundEvent\";\nimport CantBe2NumberFound from \"../finder/cantBe2NumberFound/CantBe2NumberFound\";\nimport CantBe2CantBe from \"../finder/cantBe2cantBe/CantBe2CantBe\";\nimport PairBasedExcluderInVerticalLine from \"../finder/cantBe2cantBe/PairBasedExcluderInVerticalLine\";\nimport PairBasedExcluderInHorizontalLine from \"../finder/cantBe2cantBe/PairBasedExcluderInHorizontalLine\";\nimport SubGroupBasedExcluderInBox from \"../finder/cantBe2cantBe/SubGroupBasedExcluderInBox\";\nimport SubGroupBasedExcluderInHorizontalLine from \"../finder/cantBe2cantBe/SubGroupBasedExcluderInHorizontalLine\";\n\nexport default class RuleOrchestration {\n  private numberFound2cantBeRules: NumberFound2CantBe[];\n  private cantBe2NumberFound: CantBe2NumberFound[];\n  private cantBe2CantBe: CantBe2CantBe[];\n  private eventFilter: EventFilter;\n\n  constructor() {\n    this.numberFound2cantBeRules = [\n      new BoxCantBeRule(),\n      new HorizontalCantBeRule(),\n      new VerticalCantBeRule(),\n      new OnePositionCantBeRule(),\n    ];\n\n    this.cantBe2NumberFound = [\n      new OnlyOnePlaceHorizontalLine(),\n      new OnlyOnePlaceVerticalLine(),\n      new OnlyOnePlaceBox(),\n      new OnePositionFinder(),\n    ];\n\n    this.cantBe2CantBe = [\n      new PairBasedExcluderInVerticalLine(),\n      new PairBasedExcluderInHorizontalLine(),\n      new SubGroupBasedExcluderInBox(),\n      new SubGroupBasedExcluderInHorizontalLine(),\n    ];\n\n    this.eventFilter = new EventFilter();\n  }\n\n  handleGivenNumber(\n    numberFoundEvent: NumberFoundEvent,\n    postMessage: (e: CantBeFoundEvent | NumberFoundEvent) => void,\n  ) {\n    let foundNumbers = this.eventFilter.removeAlreadySeen([numberFoundEvent]);\n    do {\n      let cantBeRulesResults: CantBeFoundEvent[] = [];\n      for (const rule of this.numberFound2cantBeRules) {\n        for (const foundNumber of foundNumbers) {\n          cantBeRulesResults = cantBeRulesResults.concat(\n            rule.finderLogic(foundNumber),\n          );\n        }\n      }\n\n      let cantBe2CantBeRulesResults: CantBeFoundEvent[] = [];\n      do {\n        cantBe2CantBeRulesResults = [];\n        for (const rule of this.cantBe2CantBe) {\n          for (const cantBe of cantBeRulesResults) {\n            cantBe2CantBeRulesResults = cantBe2CantBeRulesResults.concat(\n              rule.finderLogic(cantBeRulesResults),\n            );\n          }\n        }\n        cantBeRulesResults = cantBeRulesResults.concat(\n          cantBe2CantBeRulesResults,\n        );\n      } while (cantBe2CantBeRulesResults.length > 0);\n\n      cantBeRulesResults.forEach((it) => {\n        postMessage(it);\n      });\n\n      foundNumbers = [];\n      for (const rule of this.cantBe2NumberFound) {\n        foundNumbers = foundNumbers.concat(\n          rule.finderLogic(cantBeRulesResults),\n        );\n      }\n      foundNumbers = this.eventFilter.removeAlreadySeen(foundNumbers);\n      foundNumbers.forEach((foundNumbers) => {\n        postMessage(foundNumbers);\n      });\n    } while (foundNumbers.length > 0);\n  }\n}\n"],"names":["SudokuPosition","createAll","allYCoordinates","all","forEach","x","y","of","xCoordinate","yCoordinate","allInstances","constructor","this","getXCoordinate","getYCoordinate","toString","valueOf","SudokuBox","Error","getX","getY","getAll","flat","allBoxCoordinates","createByPosition","postion","boxXCoordinate","boxCoordinateFor","boxYCoordinate","coordinate","sudokuCoordinateFor","create","allSudokuPositionInThisBox","result","yC","xC","position","push","SudokuEventType","CantBeFoundEvent","number","from","type","CANT_BE","getNumber","getPosition","getFrom","BoxCantBeRule","ruleName","finderLogic","numberFoundEvent","box","HorizontalCantBeRule","name","xk","yk","VerticalCantBeRule","OnePositionCantBeRule","i","NumberFoundEvent","NUMBER_FOUND","OnlyOnePlaceHorizontalLine","memory","initMemory","Map","numbers","map1","set","cantBes","cantBe","_this$memory$get","canBeForNumberInLine","get","find","it","length","onlyPossiblePosition","yCoordinates","OnlyOnePlaceVerticalLine","xCoordinates","samePosition","one","two","OnlyOnePlaceBox","init","results","info","nTNumber","notHeres","newPos","OnePositionFinder","notThisNumber","createBoolean3dArray","event","anzFalse","lastFalsePosition","array3d","j","k","EventFilter","numberFound","removeAlreadySeen","toFilter","filtered","getAllPossiblePositions","filter","pos","indexOf","getYCoordinatesOf","possiblePositions","distinct","map","getXCoordinatesOf","list","e","self","PairBasedExcluderInVerticalLine","yCoordinatesOfPossiblePositions","newCantBeFoundEvent","generateCantBeFoundEventFor","PairBasedExcluderInHorizontalLine","xCoordinatesOfPossiblePositions","SubGroupBasedExcluderInBox","boxToPositionsToPossibleNumbers","positionToPossibleNumbers","Set","affectedBoxes","delete","add","positionsToPossibleNumber","positionsWithPossibleNumber","Array","entries","groupSize","groups","findGroups","group","otherPositions","some","_ref","gPos","generateCantBeFoundEventForPositions","combinations","getCombinations","combination","firstPos","firstNumbers","size","every","_ref2","setsAreEqual","item","index","slice","smallerCombination","setA","setB","a","has","positions","SudokuHorizontalLine","lineCoordinate","allLines","allSudokuPositionInThisLine","SubGroupBasedExcluderInHorizontalLine","lineToPositionsToPossibleNumbers","line","affectedLines","ruleOrchestration","numberFound2cantBeRules","cantBe2NumberFound","cantBe2CantBe","eventFilter","handleGivenNumber","postMessage","foundNumbers","cantBeRulesResults","rule","foundNumber","concat","cantBe2CantBeRulesResults","addEventListener","data","console","log","sudokuEvent","field","value"],"sourceRoot":""}