(()=>{"use strict";class t{static createAll(){const o=[0,1,2,3,4,5,6,7,8],e=[[],[],[],[],[],[],[],[],[]];return[0,1,2,3,4,5,6,7,8].forEach((n=>{o.forEach((o=>{e[n][o]=new t(n,o)}))})),e}static of(o,e){return t.allInstances[o][e]}constructor(t,o){this.xCoordinate=void 0,this.yCoordinate=void 0,this.xCoordinate=t,this.yCoordinate=o}getXCoordinate(){return this.xCoordinate}getYCoordinate(){return this.yCoordinate}toString(){return"Pos: ["+this.xCoordinate+","+this.yCoordinate+"]"}valueOf(){return"["+this.xCoordinate+"]["+this.yCoordinate+"]"}}t.allInstances=t.createAll();class o{constructor(t,o){if(this.x=void 0,this.y=void 0,t<0||o<0||t>2||o>2)throw new Error("illegal argument x:"+t+" y: "+o);this.x=t,this.y=o}getX(){return this.x}getY(){return this.y}static getAll(){return this.allInstances.flat()}static createAll(){const t=[0,1,2],e=[[],[],[]];return t.forEach((n=>{t.forEach((t=>{e[n][t]=new o(n,t)}))})),e}static createByPosition(t){const o=t.getXCoordinate(),e=t.getYCoordinate(),n=this.boxCoordinateFor(o),i=this.boxCoordinateFor(e);return this.allInstances[n][i]}static boxCoordinateFor(t){return 0===t||1===t||2===t?0:3===t||4===t||5===t?1:2}static sudokuCoordinateFor(t){return 0===t?[0,1,2]:1===t?[3,4,5]:[6,7,8]}static create(t,o){return this.allInstances[t][o]}allSudokuPositionInThisBox(){let e=[];return o.sudokuCoordinateFor(this.y).forEach((n=>{o.sudokuCoordinateFor(this.x).forEach((o=>{const i=t.of(o,n);e.push(i)}))})),e}toString(){return"Box: ["+this.x+","+this.y+"]"}}var e;o.allInstances=o.createAll(),function(t){t[t.CANT_BE=0]="CANT_BE",t[t.NUMBER_FOUND=1]="NUMBER_FOUND"}(e||(e={}));const n=e;class i{constructor(t,o,e){this.type=n.CANT_BE,this.position=void 0,this.number=void 0,this.from=void 0,this.position=t,this.number=o,this.from=e}getNumber(){return this.number}getPosition(){return this.position}getFrom(){return this.from}}class r{constructor(){this.ruleName="BoxCantBeRule"}finderLogic(t){const e=[],n=o.createByPosition(t.getPosition());for(let o of n.allSudokuPositionInThisBox())o.getYCoordinate()===t.getPosition().getYCoordinate()&&o.getXCoordinate()===t.getPosition().getXCoordinate()||e.push(new i(o,t.getNumber(),this.ruleName));return e}}class s{constructor(){this.name="HorizontalCantBeRule"}finderLogic(o){const e=[];let n=o.getPosition().getXCoordinate();return[0,1,2,3,4,5,6,7,8].forEach((r=>{r!==o.getPosition().getYCoordinate()&&e.push(new i(t.of(n,r),o.getNumber(),this.name))})),e}}class a{constructor(){this.name="VerticalCantBeRule"}finderLogic(o){const e=[];let n=o.getPosition().getYCoordinate();return[0,1,2,3,4,5,6,7,8].forEach((r=>{r!==o.getPosition().getXCoordinate()&&e.push(new i(t.of(r,n),o.getNumber(),this.name))})),e}}class c{constructor(){this.name="OnePositionCantBeRule"}finderLogic(t){const o=[];return[1,2,3,4,5,6,7,8,9].forEach((e=>{e!==t.getNumber()&&o.push(new i(t.getPosition(),e,this.name))})),o}}class u{constructor(t,o,e){this.type=n.NUMBER_FOUND,this.position=void 0,this.number=void 0,this.from=void 0,this.position=t,this.number=o,this.from=e}getNumber(){return this.number}getPosition(){return this.position}getFrom(){return this.from}}class l{constructor(){this.memory=void 0,this.name="OnlyOnePlaceHorizontalLine",this.memory=l.initMemory()}static initMemory(){const t=new Map,o=[1,2,3,4,5,6,7,8,9];for(let e=0;e<9;e++){let n=new Map;o.forEach((t=>{n.set(t,[])})),t.set(e,n)}return t}finderLogic(t){const o=[];return t.forEach((t=>{var e;const n=(null===(e=this.memory.get(t.getPosition().getXCoordinate()))||void 0===e?void 0:e.get(t.getNumber()))||[];n.find((o=>o.getXCoordinate()===t.getPosition().getXCoordinate()&&o.getYCoordinate()===t.getPosition().getYCoordinate()))||(n.push(t.getPosition()),8===n.length&&o.push(new u(l.onlyPossiblePosition(n),t.getNumber(),this.name)))})),o}static onlyPossiblePosition(o){const e=[0,1,2,3,4,5,6,7,8];for(let n=0;n<e.length;n++){let i=e[n];if(!o.find((t=>t.getYCoordinate()===i)))return t.of(o[0].getXCoordinate(),i)}throw new Error("should not happen")}}class h{constructor(){this.memory=void 0,this.name="OnlyOnePlaceVerticalLine",this.memory=h.initMemory()}static initMemory(){const t=[1,2,3,4,5,6,7,8,9],o=new Map;return[0,1,2,3,4,5,6,7,8].forEach((e=>{let n=new Map;t.forEach((t=>{n.set(t,[])})),o.set(e,n)})),o}finderLogic(t){const o=[];return t.forEach((t=>{var e;const n=(null===(e=this.memory.get(t.getPosition().getYCoordinate()))||void 0===e?void 0:e.get(t.getNumber()))||[];n.find((o=>o.getXCoordinate()===t.getPosition().getXCoordinate()&&o.getYCoordinate()===t.getPosition().getYCoordinate()))||(n.push(t.getPosition()),8===n.length&&o.push(new u(h.onlyPossiblePosition(n),t.getNumber(),this.name)))})),o}static onlyPossiblePosition(o){const e=[0,1,2,3,4,5,6,7,8];for(let n=0;n<e.length;n++){let i=e[n];if(!o.find((t=>t.getXCoordinate()===i)))return t.of(i,o[0].getYCoordinate())}throw new Error("should not happen")}}function f(t,o){return t.getXCoordinate()===o.getXCoordinate()&&t.getYCoordinate()===o.getYCoordinate()}class d{constructor(){this.memory=d.init(),this.name="OnlyOnePlaceBox"}static init(){const t=[1,2,3,4,5,6,7,8,9],e=new Map;for(let n=0;n<3;n++)for(let i=0;i<3;i++){let r=new Map;t.forEach((t=>{r.set(t,[])})),e.set(o.create(n,i),r)}return e}finderLogic(t){const e=[];for(let i of t){var n;let t=i.getPosition(),r=i.getNumber(),s=o.createByPosition(t);const a=null===(n=this.memory.get(s))||void 0===n?void 0:n.get(r);a&&!a.find((o=>f(t,o)))&&(a.push(t),8===a.length&&s.allSudokuPositionInThisBox().forEach((t=>{a.find((o=>f(t,o)))||e.push(new u(t,r,this.name))})))}return e}}class g{constructor(){this.notThisNumber=g.createBoolean3dArray(),this.name="OnePositionFinder"}finderLogic(t){const o=[];for(let e of t){const t=e.getPosition(),n=e.getNumber();this.notThisNumber[t.getXCoordinate()][t.getYCoordinate()][n]=!0;let i=0,r=null;[1,2,3,4,5,6,7,8,9].forEach((o=>{this.notThisNumber[t.getXCoordinate()][t.getYCoordinate()][o]||(i++,r=o)})),1===i&&null!==r&&o.push(new u(t,r,this.name))}return o}static createBoolean3dArray(){const t=[];for(let o=0;o<9;o++){t[o]=[];for(let e=0;e<9;e++){t[o][e]=[];for(let n=0;n<9;n++)t[o][e][n]=!1}}return t}}class m{constructor(){this.numberFound=[[],[],[],[],[],[],[],[],[]]}removeAlreadySeen(t){const o=[];for(const e of t)e.type===n.NUMBER_FOUND?this.numberFound[e.getPosition().getXCoordinate()][e.getPosition().getYCoordinate()]||(this.numberFound[e.getPosition().getXCoordinate()][e.getPosition().getYCoordinate()]=e.getNumber(),o.push(e)):o.push(e);return o}}function P(t,o){return o.allSudokuPositionInThisBox().filter((o=>t.indexOf(o)<0))}function C(t){return p(t.map((t=>t.getYCoordinate())))}function b(t){return p(t.map((t=>t.getXCoordinate())))}function p(t){return t.filter(((t,o,e)=>o===e.indexOf(t)))}class w{constructor(){this.memory=w.init(),this.name="PairBasedExcluderInVerticalLine"}static init(){const t=[1,2,3,4,5,6,7,8,9],e=new Map;for(let n=0;n<3;n++)for(let i=0;i<3;i++){let r=new Map;t.forEach((t=>{r.set(t,[])})),e.set(o.create(n,i),r)}return e}finderLogic(t){const e=[];for(let i of t){var n;let t=i.getPosition(),r=i.getNumber(),s=o.createByPosition(t);const a=null===(n=this.memory.get(s))||void 0===n?void 0:n.get(r);if(a&&!a.find((o=>{return n=o,(e=t).getXCoordinate()===n.getXCoordinate()&&e.getYCoordinate()===n.getYCoordinate();var e,n}))&&(a.push(t),a.length>=6&&a.length<=7)){const t=C(P(a,s));if(1===t.length){const o=y(t[0],r,s);e.push(...o)}}}return e}}function y(o,e,n){return[0,1,2,3,4,5,6,7,8].map((e=>t.of(e,o))).filter((t=>n.allSudokuPositionInThisBox().indexOf(t)<0)).map((t=>new i(t,e,w.name)))}class v{constructor(){this.memory=v.init(),this.name="PairBasedExcluderInHorizontalLine"}static init(){const t=[1,2,3,4,5,6,7,8,9],e=new Map;for(let n=0;n<3;n++)for(let i=0;i<3;i++){let r=new Map;t.forEach((t=>{r.set(t,[])})),e.set(o.create(n,i),r)}return e}finderLogic(t){const e=[];for(let i of t){var n;let t=i.getPosition(),r=i.getNumber(),s=o.createByPosition(t);const a=null===(n=this.memory.get(s))||void 0===n?void 0:n.get(r);if(a&&!a.find((o=>{return n=o,(e=t).getXCoordinate()===n.getXCoordinate()&&e.getYCoordinate()===n.getYCoordinate();var e,n}))&&(a.push(t),a.length>=6&&a.length<=7)){const t=b(P(a,s));if(1===t.length){const o=N(t[0],r,s);e.push(...o)}}}return e}}function N(o,e,n){return[0,1,2,3,4,5,6,7,8].map((e=>t.of(o,e))).filter((t=>n.allSudokuPositionInThisBox().indexOf(t)<0)).map((t=>new i(t,e,v.name)))}class B{constructor(){this.boxToPositionsToPossibleNumbers=void 0,this.boxToPositionsToPossibleNumbers=new Map;for(const t of o.getAll()){const o=new Map;for(const e of t.allSudokuPositionInThisBox())o.set(e,new Set([1,2,3,4,5,6,7,8,9]));this.boxToPositionsToPossibleNumbers.set(t,o)}}finderLogic(t){const e=[],n=new Set;for(const i of t){const t=o.createByPosition(i.getPosition()),e=i.getPosition(),r=i.getNumber();this.boxToPositionsToPossibleNumbers.get(t).get(e).delete(r)&&n.add(t)}for(const o of n){const t=this.boxToPositionsToPossibleNumbers.get(o),n=Array.from(t.entries());for(let i=2;i<=8;i++){const t=this.findGroups(n,i);for(const n of t){const t=Array.from(n[0][1]),i=Array.from(o.allSudokuPositionInThisBox()).filter((t=>!n.some((o=>{let[e]=o;return e===t}))));for(const o of t)e.push(...E(i,o))}}}return e}findGroups(t,o){const e=[],n=this.getCombinations(t,o);for(const i of n){const[t,n]=i[0];n.size===o&&i.every((t=>{let[,o]=t;return this.setsAreEqual(o,n)}))&&e.push(i)}return e}getCombinations(t,o){if(o>t.length)return[];if(1===o)return t.map((t=>[t]));const e=[];return t.forEach(((n,i)=>{this.getCombinations(t.slice(i+1),o-1).forEach((t=>{e.push([n,...t])}))})),e}setsAreEqual(t,o){if(t.size!==o.size)return!1;for(const e of t)if(!o.has(e))return!1;return!0}}function E(t,o){return t.map((t=>new i(t,o,B.name)))}class T{constructor(t){this.lineCoordinate=void 0,this.lineCoordinate=t}static getAll(){return T.allLines}allSudokuPositionInThisLine(){return[0,1,2,3,4,5,6,7,8].map((o=>t.of(this.lineCoordinate,o)))}static createByPosition(t){return T.allLines[t.getXCoordinate()]}}T.allLines=[new T(0),new T(1),new T(2),new T(3),new T(4),new T(5),new T(6),new T(7),new T(8)];class x{constructor(){this.lineToPositionsToPossibleNumbers=void 0,this.lineToPositionsToPossibleNumbers=new Map;for(const t of T.getAll()){const o=new Map;for(const e of t.allSudokuPositionInThisLine())o.set(e,new Set([1,2,3,4,5,6,7,8,9]));this.lineToPositionsToPossibleNumbers.set(t,o)}}finderLogic(t){const o=[],e=new Set;for(const n of t){const t=T.createByPosition(n.getPosition()),o=n.getPosition(),i=n.getNumber();this.lineToPositionsToPossibleNumbers.get(t).get(o).delete(i)&&e.add(t)}for(const n of e){const t=this.lineToPositionsToPossibleNumbers.get(n),e=Array.from(t.entries());for(let i=2;i<=8;i++){const t=this.findGroups(e,i);for(const e of t){const t=Array.from(e[0][1]),i=Array.from(n.allSudokuPositionInThisLine()).filter((t=>!e.some((o=>{let[e]=o;return e===t}))));for(const e of t)o.push(...A(i,e))}}}return o}findGroups(t,o){const e=[],n=this.getCombinations(t,o);for(const i of n){const[t,n]=i[0];n.size===o&&i.every((t=>{let[,o]=t;return this.setsAreEqual(o,n)}))&&e.push(i)}return e}getCombinations(t,o){if(o>t.length)return[];if(1===o)return t.map((t=>[t]));const e=[];return t.forEach(((n,i)=>{this.getCombinations(t.slice(i+1),o-1).forEach((t=>{e.push([n,...t])}))})),e}setsAreEqual(t,o){if(t.size!==o.size)return!1;for(const e of t)if(!o.has(e))return!1;return!0}}function A(t,o){return t.map((t=>new i(t,o,x.name)))}let F=new class{constructor(){this.numberFound2cantBeRules=void 0,this.cantBe2NumberFound=void 0,this.cantBe2CantBe=void 0,this.eventFilter=void 0,this.numberFound2cantBeRules=[new r,new s,new a,new c],this.cantBe2NumberFound=[new l,new h,new d,new g],this.cantBe2CantBe=[new w,new v,new B,new x],this.eventFilter=new m}handleGivenNumber(t,o){let e=this.eventFilter.removeAlreadySeen([t]);do{let t=[];for(const o of this.numberFound2cantBeRules)for(const n of e)t=t.concat(o.finderLogic(n));let n=[];do{n=[];for(const o of this.cantBe2CantBe)for(const e of t)n=n.concat(o.finderLogic(t));t=t.concat(n)}while(n.length>0);t.forEach((t=>{o(t)})),e=[];for(const o of this.cantBe2NumberFound)e=e.concat(o.finderLogic(t));e=this.eventFilter.removeAlreadySeen(e),e.forEach((t=>{o(t)}))}while(e.length>0)}};addEventListener("message",(({data:o})=>{console.log("worker got message",o);let e=new u(t.of(o.field[0],o.field[1]),o.value,"USER");F.handleGivenNumber(e,postMessage)}))})();
//# sourceMappingURL=sudoku.worker.f7e28c9f.worker.js.map