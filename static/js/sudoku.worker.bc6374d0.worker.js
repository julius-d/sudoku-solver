(()=>{"use strict";class t{static createAll(){const e=[0,1,2,3,4,5,6,7,8],o=[[],[],[],[],[],[],[],[],[]];return[0,1,2,3,4,5,6,7,8].forEach((n=>{e.forEach((e=>{o[n][e]=new t(n,e)}))})),o}static of(e,o){return t.allInstances[e][o]}constructor(t,e){this.xCoordinate=void 0,this.yCoordinate=void 0,this.xCoordinate=t,this.yCoordinate=e}getXCoordinate(){return this.xCoordinate}getYCoordinate(){return this.yCoordinate}toString(){return"Pos: ["+this.xCoordinate+","+this.yCoordinate+"]"}valueOf(){return"["+this.xCoordinate+"]["+this.yCoordinate+"]"}}t.allInstances=t.createAll();class e{constructor(t,e){if(this.x=void 0,this.y=void 0,t<0||e<0||t>2||e>2)throw new Error("illegal argument x:"+t+" y: "+e);this.x=t,this.y=e}getX(){return this.x}getY(){return this.y}static getAll(){return this.allInstances.flat()}static createAll(){const t=[0,1,2],o=[[],[],[]];return t.forEach((n=>{t.forEach((t=>{o[n][t]=new e(n,t)}))})),o}static createByPosition(t){const e=t.getXCoordinate(),o=t.getYCoordinate(),n=this.boxCoordinateFor(e),i=this.boxCoordinateFor(o);return this.allInstances[n][i]}static boxCoordinateFor(t){return 0===t||1===t||2===t?0:3===t||4===t||5===t?1:2}static sudokuCoordinateFor(t){return 0===t?[0,1,2]:1===t?[3,4,5]:[6,7,8]}static create(t,e){return this.allInstances[t][e]}allSudokuPositionInThisBox(){let o=[];return e.sudokuCoordinateFor(this.y).forEach((n=>{e.sudokuCoordinateFor(this.x).forEach((e=>{const i=t.of(e,n);o.push(i)}))})),o}toString(){return"Box: ["+this.x+","+this.y+"]"}}var o;e.allInstances=e.createAll(),function(t){t[t.CANT_BE=0]="CANT_BE",t[t.NUMBER_FOUND=1]="NUMBER_FOUND"}(o||(o={}));const n=o;class i{constructor(t,e,o){this.type=n.CANT_BE,this.position=void 0,this.number=void 0,this.from=void 0,this.position=t,this.number=e,this.from=o}getNumber(){return this.number}getPosition(){return this.position}getFrom(){return this.from}}class r{constructor(){this.ruleName="BoxCantBeRule"}finderLogic(t){const o=[],n=e.createByPosition(t.getPosition());for(let e of n.allSudokuPositionInThisBox())e.getYCoordinate()===t.getPosition().getYCoordinate()&&e.getXCoordinate()===t.getPosition().getXCoordinate()||o.push(new i(e,t.getNumber(),this.ruleName));return o}}class s{constructor(){this.name="HorizontalCantBeRule"}finderLogic(e){const o=[];let n=e.getPosition().getXCoordinate();return[0,1,2,3,4,5,6,7,8].forEach((r=>{r!==e.getPosition().getYCoordinate()&&o.push(new i(t.of(n,r),e.getNumber(),this.name))})),o}}class a{constructor(){this.name="VerticalCantBeRule"}finderLogic(e){const o=[];let n=e.getPosition().getYCoordinate();return[0,1,2,3,4,5,6,7,8].forEach((r=>{r!==e.getPosition().getXCoordinate()&&o.push(new i(t.of(r,n),e.getNumber(),this.name))})),o}}class c{constructor(){this.name="OnePositionCantBeRule"}finderLogic(t){const e=[];return[1,2,3,4,5,6,7,8,9].forEach((o=>{o!==t.getNumber()&&e.push(new i(t.getPosition(),o,this.name))})),e}}class u{constructor(t,e,o){this.type=n.NUMBER_FOUND,this.position=void 0,this.number=void 0,this.from=void 0,this.position=t,this.number=e,this.from=o}getNumber(){return this.number}getPosition(){return this.position}getFrom(){return this.from}}class l{constructor(){this.memory=void 0,this.name="OnlyOnePlaceHorizontalLine",this.memory=l.initMemory()}static initMemory(){const t=new Map,e=[1,2,3,4,5,6,7,8,9];for(let o=0;o<9;o++){let n=new Map;e.forEach((t=>{n.set(t,[])})),t.set(o,n)}return t}finderLogic(t){const e=[];return t.forEach((t=>{var o;const n=(null===(o=this.memory.get(t.getPosition().getXCoordinate()))||void 0===o?void 0:o.get(t.getNumber()))||[];n.find((e=>e.getXCoordinate()===t.getPosition().getXCoordinate()&&e.getYCoordinate()===t.getPosition().getYCoordinate()))||(n.push(t.getPosition()),8===n.length&&e.push(new u(l.onlyPossiblePosition(n),t.getNumber(),this.name)))})),e}static onlyPossiblePosition(e){const o=[0,1,2,3,4,5,6,7,8];for(let n=0;n<o.length;n++){let i=o[n];if(!e.find((t=>t.getYCoordinate()===i)))return t.of(e[0].getXCoordinate(),i)}throw new Error("should not happen")}}class h{constructor(){this.memory=void 0,this.name="OnlyOnePlaceVerticalLine",this.memory=h.initMemory()}static initMemory(){const t=[1,2,3,4,5,6,7,8,9],e=new Map;return[0,1,2,3,4,5,6,7,8].forEach((o=>{let n=new Map;t.forEach((t=>{n.set(t,[])})),e.set(o,n)})),e}finderLogic(t){const e=[];return t.forEach((t=>{var o;const n=(null===(o=this.memory.get(t.getPosition().getYCoordinate()))||void 0===o?void 0:o.get(t.getNumber()))||[];n.find((e=>e.getXCoordinate()===t.getPosition().getXCoordinate()&&e.getYCoordinate()===t.getPosition().getYCoordinate()))||(n.push(t.getPosition()),8===n.length&&e.push(new u(h.onlyPossiblePosition(n),t.getNumber(),this.name)))})),e}static onlyPossiblePosition(e){const o=[0,1,2,3,4,5,6,7,8];for(let n=0;n<o.length;n++){let i=o[n];if(!e.find((t=>t.getXCoordinate()===i)))return t.of(i,e[0].getYCoordinate())}throw new Error("should not happen")}}function d(t,e){return t.getXCoordinate()===e.getXCoordinate()&&t.getYCoordinate()===e.getYCoordinate()}class g{constructor(){this.memory=g.init(),this.name="OnlyOnePlaceBox"}static init(){const t=[1,2,3,4,5,6,7,8,9],o=new Map;for(let n=0;n<3;n++)for(let i=0;i<3;i++){let r=new Map;t.forEach((t=>{r.set(t,[])})),o.set(e.create(n,i),r)}return o}finderLogic(t){const o=[];for(let i of t){var n;let t=i.getPosition(),r=i.getNumber(),s=e.createByPosition(t);const a=null===(n=this.memory.get(s))||void 0===n?void 0:n.get(r);a&&!a.find((e=>d(t,e)))&&(a.push(t),8===a.length&&s.allSudokuPositionInThisBox().forEach((t=>{a.find((e=>d(t,e)))||o.push(new u(t,r,this.name))})))}return o}}class f{constructor(){this.notThisNumber=f.createBoolean3dArray(),this.name="OnePositionFinder"}finderLogic(t){const e=[];for(let o of t){const t=o.getPosition(),n=o.getNumber();this.notThisNumber[t.getXCoordinate()][t.getYCoordinate()][n]=!0;let i=0,r=null;[1,2,3,4,5,6,7,8,9].forEach((e=>{this.notThisNumber[t.getXCoordinate()][t.getYCoordinate()][e]||(i++,r=e)})),1===i&&null!==r&&e.push(new u(t,r,this.name))}return e}static createBoolean3dArray(){const t=[];for(let e=0;e<9;e++){t[e]=[];for(let o=0;o<9;o++){t[e][o]=[];for(let n=0;n<9;n++)t[e][o][n]=!1}}return t}}class m{constructor(){this.numberFound=[[],[],[],[],[],[],[],[],[]]}removeAlreadySeen(t){const e=[];for(const o of t)o.type===n.NUMBER_FOUND?this.numberFound[o.getPosition().getXCoordinate()][o.getPosition().getYCoordinate()]||(this.numberFound[o.getPosition().getXCoordinate()][o.getPosition().getYCoordinate()]=o.getNumber(),e.push(o)):e.push(o);return e}}function C(t,e){return e.allSudokuPositionInThisBox().filter((e=>t.indexOf(e)<0))}function p(t){return y(t.map((t=>t.getYCoordinate())))}function P(t){return y(t.map((t=>t.getXCoordinate())))}function y(t){return t.filter(((t,e,o)=>e===o.indexOf(t)))}class w{constructor(){this.memory=w.init(),this.name="PairBasedExcluderInVerticalLine"}static init(){const t=[1,2,3,4,5,6,7,8,9],o=new Map;for(let n=0;n<3;n++)for(let i=0;i<3;i++){let r=new Map;t.forEach((t=>{r.set(t,[])})),o.set(e.create(n,i),r)}return o}finderLogic(t){const o=[];for(let i of t){var n;let t=i.getPosition(),r=i.getNumber(),s=e.createByPosition(t);const a=null===(n=this.memory.get(s))||void 0===n?void 0:n.get(r);if(a&&!a.find((e=>{return n=e,(o=t).getXCoordinate()===n.getXCoordinate()&&o.getYCoordinate()===n.getYCoordinate();var o,n}))&&(a.push(t),a.length>=6&&a.length<=7)){const t=p(C(a,s));if(1===t.length){const e=b(t[0],r,s);o.push(...e)}}}return o}}function b(e,o,n){return[0,1,2,3,4,5,6,7,8].map((o=>t.of(o,e))).filter((t=>n.allSudokuPositionInThisBox().indexOf(t)<0)).map((t=>new i(t,o,w.name)))}class v{constructor(){this.memory=v.init(),this.name="PairBasedExcluderInHorizontalLine"}static init(){const t=[1,2,3,4,5,6,7,8,9],o=new Map;for(let n=0;n<3;n++)for(let i=0;i<3;i++){let r=new Map;t.forEach((t=>{r.set(t,[])})),o.set(e.create(n,i),r)}return o}finderLogic(t){const o=[];for(let i of t){var n;let t=i.getPosition(),r=i.getNumber(),s=e.createByPosition(t);const a=null===(n=this.memory.get(s))||void 0===n?void 0:n.get(r);if(a&&!a.find((e=>{return n=e,(o=t).getXCoordinate()===n.getXCoordinate()&&o.getYCoordinate()===n.getYCoordinate();var o,n}))&&(a.push(t),a.length>=6&&a.length<=7)){const t=P(C(a,s));if(1===t.length){const e=B(t[0],r,s);o.push(...e)}}}return o}}function B(e,o,n){return[0,1,2,3,4,5,6,7,8].map((o=>t.of(e,o))).filter((t=>n.allSudokuPositionInThisBox().indexOf(t)<0)).map((t=>new i(t,o,v.name)))}class N{constructor(){this.boxMap=void 0,this.boxMap=new Map;for(const t of e.getAll()){const e=new Map;for(const o of t.allSudokuPositionInThisBox())e.set(o,new Set([1,2,3,4,5,6,7,8,9]));this.boxMap.set(t,e)}}finderLogic(t){const o=[],n=new Set;for(const i of t){const t=e.createByPosition(i.getPosition()),o=i.getPosition(),r=i.getNumber();this.boxMap.get(t).get(o).delete(r)&&n.add(t)}for(const e of n){const t=this.boxMap.get(e),n=[],i=Array.from(t.entries());for(let e=0;e<i.length;e++)for(let t=e+1;t<i.length;t++){const[o,r]=i[e],[s,a]=i[t];2===r.size&&2===a.size&&[...r].every((t=>a.has(t)))&&n.push([o,s])}for(const[r,s]of n){const n=Array.from(t.get(r)),i=Array.from(e.allSudokuPositionInThisBox()).filter((t=>t!==r&&t!==s));for(const t of n)o.push(...x(i,t))}}return o}}function x(t,e){return t.map((t=>new i(t,e,N.name)))}let E=new class{constructor(){this.numberFound2cantBeRules=void 0,this.cantBe2NumberFound=void 0,this.cantBe2CantBe=void 0,this.eventFilter=void 0,this.numberFound2cantBeRules=[new r,new s,new a,new c],this.cantBe2NumberFound=[new l,new h,new g,new f],this.cantBe2CantBe=[new w,new v,new N],this.eventFilter=new m}handleGivenNumber(t,e){let o=this.eventFilter.removeAlreadySeen([t]);do{let t=[];for(const e of this.numberFound2cantBeRules)for(const n of o)t=t.concat(e.finderLogic(n));let n=[];do{n=[];for(const e of this.cantBe2CantBe)for(const o of t)n=n.concat(e.finderLogic(t));t=t.concat(n)}while(n.length>0);t.forEach((t=>{e(t)})),o=[];for(const e of this.cantBe2NumberFound)o=o.concat(e.finderLogic(t));o=this.eventFilter.removeAlreadySeen(o),o.forEach((t=>{e(t)}))}while(o.length>0)}};addEventListener("message",(({data:e})=>{console.log("worker got message",e);let o=new u(t.of(e.field[0],e.field[1]),e.value,"USER");E.handleGivenNumber(o,postMessage)}))})();
//# sourceMappingURL=sudoku.worker.bc6374d0.worker.js.map